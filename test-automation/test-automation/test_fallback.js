const fs = require('fs');

// Simulate the fallback template generation
function sanitizeIssueTitle(title) {
  if (\!title || typeof title \!== 'string') {
    return 'No title';
  }
  return title.replace(/[<>&"']/g, '_').slice(0, 200);
}

function createBugfixTemplate(issue, analysis) {
  return `#\!/usr/bin/env python3
"""
Automated bugfix for Issue #${issue.number}
Title: ${sanitizeIssueTitle(issue.title)}
Generated by Claude Code automation (fallback mode)
"""

import logging
import sys
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

def bugfix_${issue.number}():
    """
    Automated bugfix implementation for Issue #${issue.number}
    
    Returns:
        bool: True if fix applied successfully, False otherwise
    """
    try:
        logger.info(f"Applying bugfix for Issue #${issue.number}")
        
        # TODO: Implement actual fix logic here
        # Based on issue description: ${sanitizeIssueTitle(issue.title)}
        
        logger.info("Bugfix #${issue.number} applied successfully")
        return True
        
    except Exception as e:
        logger.error(f"Bugfix #${issue.number} failed: {e}")
        return False

if __name__ == "__main__":
    success = bugfix_${issue.number}()
    sys.exit(0 if success else 1)
`;
}

// Test issue data
const testIssue = {
  number: 5,
  title: 'Test Claude automation system with fallback functionality'
};

const testAnalysis = {
  type: 'bugfix',
  priority: 'high',
  complexity: 'simple'
};

// Create src directory
if (\!fs.existsSync('src')) {
  fs.mkdirSync('src');
}

// Generate bugfix template
const bugfixContent = createBugfixTemplate(testIssue, testAnalysis);
const bugfixFile = 'src/bugfix_' + testIssue.number + '.py';

fs.writeFileSync(bugfixFile, bugfixContent);
console.log('‚úÖ Generated bugfix template:', bugfixFile);
console.log('üìÑ File size:', fs.statSync(bugfixFile).size, 'bytes');
console.log('üîç Content preview:');
console.log(bugfixContent.split('\n').slice(0, 15).join('\n'));
EOF < /dev/null