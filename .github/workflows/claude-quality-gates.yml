name: Claude Quality Assurance Pipeline & Pre-Merge Gates

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: [main, develop]
  pull_request_review:
    types: [submitted]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number for manual quality assessment'
        required: true
        type: number
      gate_level:
        description: 'Quality gate enforcement level'
        required: false
        default: 'standard'
        type: choice
        options:
          - 'basic'
          - 'standard' 
          - 'strict'

jobs:
  quality-gates:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
      checks: write
      actions: read
      
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ github.token }}
        ref: ${{ github.event.pull_request.head.sha || 'main' }}
        
    - name: Quality Assurance Pipeline Engine
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          console.log('🎯 CLAUDE QUALITY ASSURANCE PIPELINE ACTIVATED');
          const startTime = Date.now();
          const executionId = Math.random().toString(36).substring(7);
          const timestamp = new Date().toISOString();
          
          const prNumber = context.payload.pull_request?.number || 
                          context.payload.inputs?.pr_number;
          const gateLevel = context.payload.inputs?.gate_level || 'standard';
          
          console.log(`🔍 PR Number: ${prNumber}`);
          console.log(`🎯 Gate Level: ${gateLevel}`);
          console.log(`⚡ Execution ID: ${executionId}`);
          
          if (!prNumber) {
            console.log('❌ No PR number found');
            return;
          }
          
          // Quality gate thresholds by level
          const qualityThresholds = {
            basic: {
              maxFilesChanged: 50,
              maxLinesChanged: 1000,
              minTestCoverage: 0,
              maxComplexityScore: 100,
              securityScanRequired: false,
              performanceTestRequired: false
            },
            standard: {
              maxFilesChanged: 25,
              maxLinesChanged: 500,
              minTestCoverage: 70,
              maxComplexityScore: 80,
              securityScanRequired: true,
              performanceTestRequired: false
            },
            strict: {
              maxFilesChanged: 15,
              maxLinesChanged: 300,
              minTestCoverage: 85,
              maxComplexityScore: 60,
              securityScanRequired: true,
              performanceTestRequired: true
            }
          };
          
          const thresholds = qualityThresholds[gateLevel];
          console.log(`📊 Quality thresholds:`, JSON.stringify(thresholds, null, 2));
          
          // Quality metrics tracking
          const qualityMetrics = {
            filesChanged: 0,
            linesAdded: 0,
            linesDeleted: 0,
            totalChanges: 0,
            testCoverage: 0,
            complexityScore: 0,
            securityScore: 100,
            performanceScore: 100,
            overallQualityScore: 0,
            gatesPassed: 0,
            gatesFailed: 0,
            criticalIssues: [],
            warnings: [],
            recommendations: [],
            startTime: startTime
          };
          
          try {
            console.log('\n🔍 === PHASE 1: PR ANALYSIS & METRICS COLLECTION ===');
            
            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            console.log(`📋 PR #${prNumber}: ${pr.data.title}`);
            console.log(`👤 Author: ${pr.data.user.login}`);
            console.log(`🌿 Branch: ${pr.data.head.ref} -> ${pr.data.base.ref}`);
            
            // Get PR files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            qualityMetrics.filesChanged = files.data.length;
            qualityMetrics.linesAdded = pr.data.additions;
            qualityMetrics.linesDeleted = pr.data.deletions;
            qualityMetrics.totalChanges = qualityMetrics.linesAdded + qualityMetrics.linesDeleted;
            
            console.log(`📊 Files changed: ${qualityMetrics.filesChanged}`);
            console.log(`📈 Lines added: ${qualityMetrics.linesAdded}`);
            console.log(`📉 Lines deleted: ${qualityMetrics.linesDeleted}`);
            console.log(`📊 Total changes: ${qualityMetrics.totalChanges}`);
            
            console.log('\n🎯 === PHASE 2: QUALITY GATE VALIDATION ===');
            
            // Gate 1: File Change Limit
            console.log(`\n📁 Gate 1: File Change Limit (${qualityMetrics.filesChanged}/${thresholds.maxFilesChanged})`);
            if (qualityMetrics.filesChanged <= thresholds.maxFilesChanged) {
              console.log('✅ PASS: File change limit within threshold');
              qualityMetrics.gatesPassed++;
            } else {
              console.log('❌ FAIL: Too many files changed');
              qualityMetrics.gatesFailed++;
              qualityMetrics.criticalIssues.push(`Excessive file changes: ${qualityMetrics.filesChanged} > ${thresholds.maxFilesChanged}`);
            }
            
            // Gate 2: Line Change Limit
            console.log(`\n📏 Gate 2: Line Change Limit (${qualityMetrics.totalChanges}/${thresholds.maxLinesChanged})`);
            if (qualityMetrics.totalChanges <= thresholds.maxLinesChanged) {
              console.log('✅ PASS: Line change limit within threshold');
              qualityMetrics.gatesPassed++;
            } else {
              console.log('❌ FAIL: Too many lines changed');
              qualityMetrics.gatesFailed++;
              qualityMetrics.criticalIssues.push(`Excessive line changes: ${qualityMetrics.totalChanges} > ${thresholds.maxLinesChanged}`);
            }
            
            // Gate 3: Code Quality Analysis
            console.log(`\n🔍 Gate 3: Code Quality Analysis`);
            let codeQualityScore = 100;
            const codeQualityIssues = [];
            
            for (const file of files.data) {
              if (!file.patch) continue;
              
              const patch = file.patch;
              const fileName = file.filename;
              const extension = fileName.split('.').pop()?.toLowerCase();
              
              // Language-specific quality checks
              if (['js', 'ts', 'jsx', 'tsx'].includes(extension)) {
                // JavaScript/TypeScript quality checks
                if (patch.includes('console.log') || patch.includes('console.error')) {
                  codeQualityScore -= 5;
                  codeQualityIssues.push(`Debug statements in ${fileName}`);
                }
                if (patch.includes('var ')) {
                  codeQualityScore -= 10;
                  codeQualityIssues.push(`Use of 'var' instead of 'let'/'const' in ${fileName}`);
                }
                if (patch.includes('== ') && !patch.includes('=== ')) {
                  codeQualityScore -= 5;
                  codeQualityIssues.push(`Non-strict equality in ${fileName}`);
                }
                if (patch.includes('any')) {
                  codeQualityScore -= 3;
                  codeQualityIssues.push(`Use of 'any' type in ${fileName}`);
                }
              }
              
              if (['py'].includes(extension)) {
                // Python quality checks
                if (patch.includes('print(')) {
                  codeQualityScore -= 5;
                  codeQualityIssues.push(`Print statements in ${fileName}`);
                }
                if (patch.includes('import *')) {
                  codeQualityScore -= 10;
                  codeQualityIssues.push(`Wildcard imports in ${fileName}`);
                }
              }
              
              // General quality checks
              if (patch.includes('TODO') || patch.includes('FIXME')) {
                codeQualityScore -= 3;
                codeQualityIssues.push(`TODO/FIXME comments in ${fileName}`);
              }
              
              if (patch.includes('hack') || patch.includes('HACK')) {
                codeQualityScore -= 15;
                codeQualityIssues.push(`Hack comments in ${fileName}`);
              }
              
              // Line length analysis (simplified)
              const lines = patch.split('\n').filter(line => line.startsWith('+'));
              const longLines = lines.filter(line => line.length > 120);
              if (longLines.length > 0) {
                codeQualityScore -= longLines.length * 2;
                codeQualityIssues.push(`${longLines.length} long lines (>120 chars) in ${fileName}`);
              }
            }
            
            qualityMetrics.complexityScore = Math.max(0, 100 - codeQualityScore);
            console.log(`📊 Code Quality Score: ${codeQualityScore}/100`);
            console.log(`📊 Complexity Score: ${qualityMetrics.complexityScore}/100`);
            
            if (qualityMetrics.complexityScore <= thresholds.maxComplexityScore) {
              console.log('✅ PASS: Code quality within acceptable range');
              qualityMetrics.gatesPassed++;
            } else {
              console.log('❌ FAIL: Code quality below threshold');
              qualityMetrics.gatesFailed++;
              qualityMetrics.criticalIssues.push(`Code quality issues: ${qualityMetrics.complexityScore} > ${thresholds.maxComplexityScore}`);
            }
            
            // Gate 4: Security Analysis
            console.log(`\n🛡️ Gate 4: Security Analysis`);
            let securityScore = 100;
            const securityIssues = [];
            
            for (const file of files.data) {
              if (!file.patch) continue;
              
              const patch = file.patch;
              const fileName = file.filename;
              
              // Security pattern detection
              const securityPatterns = [
                { pattern: /password.*=.*["'][^"']*["']/gi, severity: 20, message: 'Hardcoded password' },
                { pattern: /api[_-]?key.*=.*["'][^"']*["']/gi, severity: 25, message: 'Hardcoded API key' },
                { pattern: /secret.*=.*["'][^"']*["']/gi, severity: 20, message: 'Hardcoded secret' },
                { pattern: /token.*=.*["'][^"']*["']/gi, severity: 15, message: 'Hardcoded token' },
                { pattern: /eval\s*\(/gi, severity: 30, message: 'Use of eval()' },
                { pattern: /innerHTML\s*=/gi, severity: 15, message: 'XSS risk: innerHTML usage' },
                { pattern: /document\.write\s*\(/gi, severity: 20, message: 'XSS risk: document.write' },
                { pattern: /exec\s*\(/gi, severity: 25, message: 'Code injection risk: exec()' },
                { pattern: /shell_exec\s*\(/gi, severity: 30, message: 'Command injection risk' }
              ];
              
              for (const { pattern, severity, message } of securityPatterns) {
                const matches = patch.match(pattern);
                if (matches) {
                  securityScore -= severity;
                  securityIssues.push(`${message} in ${fileName} (${matches.length} occurrence${matches.length > 1 ? 's' : ''})`);
                }
              }
            }
            
            qualityMetrics.securityScore = Math.max(0, securityScore);
            console.log(`🛡️ Security Score: ${qualityMetrics.securityScore}/100`);
            
            if (securityIssues.length === 0) {
              console.log('✅ PASS: No security issues detected');
              qualityMetrics.gatesPassed++;
            } else {
              console.log('❌ FAIL: Security issues detected');
              qualityMetrics.gatesFailed++;
              qualityMetrics.criticalIssues.push(...securityIssues);
            }
            
            // Gate 5: Performance Analysis (if required)
            if (thresholds.performanceTestRequired) {
              console.log(`\n⚡ Gate 5: Performance Analysis`);
              
              // Simplified performance analysis
              let performanceScore = 100;
              const performanceIssues = [];
              
              for (const file of files.data) {
                if (!file.patch) continue;
                
                const patch = file.patch;
                const fileName = file.filename;
                
                // Performance anti-patterns
                if (patch.includes('for') && patch.includes('for')) {
                  performanceScore -= 10;
                  performanceIssues.push(`Nested loops detected in ${fileName}`);
                }
                
                if (patch.includes('setTimeout') && patch.includes('0')) {
                  performanceScore -= 5;
                  performanceIssues.push(`setTimeout with 0 delay in ${fileName}`);
                }
                
                if (patch.includes('document.getElementById') && patch.split('document.getElementById').length > 3) {
                  performanceScore -= 8;
                  performanceIssues.push(`Multiple DOM queries in ${fileName}`);
                }
              }
              
              qualityMetrics.performanceScore = Math.max(0, performanceScore);
              console.log(`⚡ Performance Score: ${qualityMetrics.performanceScore}/100`);
              
              if (performanceScore >= 80) {
                console.log('✅ PASS: Performance analysis acceptable');
                qualityMetrics.gatesPassed++;
              } else {
                console.log('❌ FAIL: Performance concerns detected');
                qualityMetrics.gatesFailed++;
                qualityMetrics.warnings.push(...performanceIssues);
              }
            }
            
            console.log('\n📊 === PHASE 3: OVERALL QUALITY ASSESSMENT ===');
            
            // Calculate overall quality score
            const qualityComponents = [
              qualityMetrics.filesChanged <= thresholds.maxFilesChanged ? 100 : 50,
              qualityMetrics.totalChanges <= thresholds.maxLinesChanged ? 100 : 50,
              Math.max(0, 100 - qualityMetrics.complexityScore),
              qualityMetrics.securityScore,
              qualityMetrics.performanceScore
            ];
            
            qualityMetrics.overallQualityScore = qualityComponents.reduce((a, b) => a + b, 0) / qualityComponents.length;
            
            const qualityGrade = qualityMetrics.overallQualityScore >= 95 ? 'A+' :
                               qualityMetrics.overallQualityScore >= 90 ? 'A' :
                               qualityMetrics.overallQualityScore >= 80 ? 'B+' :
                               qualityMetrics.overallQualityScore >= 70 ? 'B' :
                               qualityMetrics.overallQualityScore >= 60 ? 'C' : 'F';
            
            const passThreshold = gateLevel === 'strict' ? 85 :
                                 gateLevel === 'standard' ? 75 : 60;
            
            const qualityPassed = qualityMetrics.overallQualityScore >= passThreshold && 
                                 qualityMetrics.criticalIssues.length === 0;
            
            console.log(`📊 Overall Quality Score: ${qualityMetrics.overallQualityScore.toFixed(1)}/100 (Grade: ${qualityGrade})`);
            console.log(`🎯 Quality Gates: ${qualityMetrics.gatesPassed} passed, ${qualityMetrics.gatesFailed} failed`);
            console.log(`✅ Quality Assessment: ${qualityPassed ? 'PASSED' : 'FAILED'}`);
            
            console.log('\n📋 === PHASE 4: QUALITY REPORT GENERATION ===');
            
            const executionTime = Math.round((Date.now() - startTime) / 1000);
            
            // Generate comprehensive quality report
            const qualityReport = `## 🎯 Quality Assurance Pipeline Report

### 📊 Quality Assessment Summary
**Overall Grade**: ${getGradeEmoji(qualityGrade)} **${qualityGrade}** (${qualityMetrics.overallQualityScore.toFixed(1)}/100)
**Gate Level**: ${gateLevel.toUpperCase()}
**Status**: ${qualityPassed ? '✅ **PASSED**' : '❌ **FAILED**'}
**Execution ID**: \`${executionId}\`
**Assessment Time**: ${executionTime}s

### 🔍 Quality Metrics
| Metric | Value | Threshold | Status |
|--------|-------|-----------|--------|
| 📁 Files Changed | ${qualityMetrics.filesChanged} | ≤${thresholds.maxFilesChanged} | ${qualityMetrics.filesChanged <= thresholds.maxFilesChanged ? '✅' : '❌'} |
| 📏 Lines Changed | ${qualityMetrics.totalChanges} | ≤${thresholds.maxLinesChanged} | ${qualityMetrics.totalChanges <= thresholds.maxLinesChanged ? '✅' : '❌'} |
| 🔍 Complexity Score | ${qualityMetrics.complexityScore} | ≤${thresholds.maxComplexityScore} | ${qualityMetrics.complexityScore <= thresholds.maxComplexityScore ? '✅' : '❌'} |
| 🛡️ Security Score | ${qualityMetrics.securityScore}/100 | High | ${qualityMetrics.securityScore >= 80 ? '✅' : '❌'} |
| ⚡ Performance Score | ${qualityMetrics.performanceScore}/100 | High | ${qualityMetrics.performanceScore >= 80 ? '✅' : '❌'} |

### 🎯 Quality Gates Results
**Passed**: ${qualityMetrics.gatesPassed} gates ✅
**Failed**: ${qualityMetrics.gatesFailed} gates ❌
**Success Rate**: ${Math.round((qualityMetrics.gatesPassed / (qualityMetrics.gatesPassed + qualityMetrics.gatesFailed)) * 100)}%

${qualityMetrics.criticalIssues.length > 0 ? `### ❌ Critical Issues (Must Fix)
${qualityMetrics.criticalIssues.map(issue => `- 🔴 ${issue}`).join('\n')}
` : ''}${qualityMetrics.warnings.length > 0 ? `### ⚠️ Warnings (Recommended)
${qualityMetrics.warnings.map(warning => `- 🟡 ${warning}`).join('\n')}
` : ''}### 💡 Quality Recommendations
${qualityMetrics.overallQualityScore >= 95 ? '- ✅ Excellent code quality! No improvements needed.' :
  qualityMetrics.overallQualityScore >= 85 ? '- 🟡 Good quality with minor improvements possible' :
  '- 🔴 Significant quality improvements required before merge'}

${!qualityPassed ? `### 🚫 Merge Blocked
This PR does not meet the **${gateLevel}** quality standards and cannot be merged until the following are addressed:
${qualityMetrics.criticalIssues.map(issue => `- ❌ ${issue}`).join('\n')}

**Required Actions:**
1. Fix all critical issues listed above
2. Ensure overall quality score ≥ ${passThreshold}
3. Re-run quality gates after fixes
` : `### ✅ Merge Approved
This PR meets the **${gateLevel}** quality standards and is approved for merge.

**Quality Highlights:**
- ✅ All quality gates passed
- ✅ No critical issues detected
- ✅ Quality score: ${qualityMetrics.overallQualityScore.toFixed(1)}/100
`}

### 📈 Quality Improvement Tips
- 🎯 Keep PRs small and focused (≤${thresholds.maxFilesChanged} files, ≤${thresholds.maxLinesChanged} lines)
- 🔍 Run local quality checks before submitting
- 🛡️ Always scan for security vulnerabilities
- ⚡ Consider performance impact of changes
- 📝 Add comprehensive tests for new functionality

---
🎯 **Quality Assurance Pipeline** | **${gateLevel.toUpperCase()} Standards** | **High-Grade Quality**
⚡ **Automated Quality Gates** | **Pre-Merge Protection** | **Zero-Defect Delivery**`;

            // Post quality report as PR comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: qualityReport
            });
            
            // Add quality labels
            const qualityLabels = ['qa-processed', `grade-${qualityGrade.toLowerCase().replace('+', '-plus')}`];
            
            if (qualityPassed) {
              qualityLabels.push('quality-approved', 'merge-ready');
            } else {
              qualityLabels.push('quality-blocked', 'needs-improvement');
            }
            
            if (qualityMetrics.criticalIssues.length > 0) {
              qualityLabels.push('critical-issues');
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: qualityLabels
            });
            
            // Block merge if quality gates failed
            if (!qualityPassed) {
              console.log('🚫 Creating blocking check status');
              
              try {
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: pr.data.head.sha,
                  state: 'failure',
                  target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}`,
                  description: `Quality gates failed: ${qualityMetrics.criticalIssues.length} critical issues`,
                  context: 'claude/quality-gates'
                });
              } catch (statusError) {
                console.log(`⚠️ Could not create commit status: ${statusError.message}`);
              }
            } else {
              try {
                await github.rest.repos.createCommitStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: pr.data.head.sha,
                  state: 'success',
                  target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}`,
                  description: `Quality gates passed: Grade ${qualityGrade}`,
                  context: 'claude/quality-gates'
                });
              } catch (statusError) {
                console.log(`⚠️ Could not create commit status: ${statusError.message}`);
              }
            }
            
            console.log(`✅ CLAUDE QUALITY ASSURANCE PIPELINE COMPLETED`);
            console.log(`🎯 Quality Grade: ${qualityGrade} (${qualityMetrics.overallQualityScore.toFixed(1)}/100)`);
            console.log(`✅ Merge Status: ${qualityPassed ? 'APPROVED' : 'BLOCKED'}`);
            console.log(`⚡ Execution Time: ${executionTime}s`);
            
          } catch (error) {
            console.log(`❌ Quality Assurance Pipeline Error: ${error.message}`);
            
            // Post error comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## ❌ Quality Assurance Pipeline Error

The automated quality assurance pipeline encountered an error and could not complete the assessment.

**Error**: ${error.message}
**Execution ID**: \`${executionId}\`
**Gate Level**: ${gateLevel}

**Manual Review Required**: Please proceed with manual quality review or retry the automation.

---
❌ **Quality Pipeline Error** | **Manual Intervention Needed**`
            });
            
            throw error;
          }
          
          // Helper function for grade emojis
          function getGradeEmoji(grade) {
            const emojis = {
              'A+': '🏆',
              'A': '🥇',
              'B+': '🥈',
              'B': '🥉',
              'C': '⚠️',
              'F': '❌'
            };
            return emojis[grade] || '📊';
          }