name: Claude Intelligent Workload Distribution & Load Balancing

on:
  schedule:
    # Workload analysis and redistribution every 15 minutes during peak hours
    - cron: '*/15 6-18 * * 1-5'  # Every 15min, 6-18 UTC (15-03 JST), Mon-Fri
    # Every 30 minutes during off-hours
    - cron: '*/30 18-6 * * *'     # Every 30min, 18-6 UTC (off-hours)
  workflow_dispatch:
    inputs:
      distribution_mode:
        description: 'Workload distribution mode'
        required: false
        default: 'intelligent'
        type: choice
        options:
          - 'manual'
          - 'round_robin'
          - 'load_based'
          - 'intelligent'
          - 'predictive'
      optimization_target:
        description: 'Optimization target'
        required: false
        default: 'balanced'
        type: choice
        options:
          - 'speed'
          - 'reliability'
          - 'cost'
          - 'balanced'
  workflow_run:
    workflows: ["Claude Performance Analytics", "Claude Health Monitor"]
    types: [completed]

jobs:
  workload-distribution:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: write
      checks: read
      
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ github.token }}
        
    - name: Intelligent Workload Distribution Engine
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          console.log('‚öñÔ∏è CLAUDE INTELLIGENT WORKLOAD DISTRIBUTION ENGINE ACTIVATED');
          const startTime = Date.now();
          const executionId = Math.random().toString(36).substring(7);
          const timestamp = new Date().toISOString();
          
          const distributionMode = context.payload.inputs?.distribution_mode || 'intelligent';
          const optimizationTarget = context.payload.inputs?.optimization_target || 'balanced';
          
          console.log(`‚öñÔ∏è Distribution Mode: ${distributionMode}`);
          console.log(`üéØ Optimization Target: ${optimizationTarget}`);
          console.log(`‚ö° Execution ID: ${executionId}`);
          
          // Workload distribution configuration
          const distributionConfig = {
            manual: {
              algorithm: 'user_defined',
              loadBalancing: false,
              predictiveScaling: false,
              adaptiveThresholds: false
            },
            round_robin: {
              algorithm: 'round_robin',
              loadBalancing: true,
              predictiveScaling: false,
              adaptiveThresholds: false
            },
            load_based: {
              algorithm: 'load_aware',
              loadBalancing: true,
              predictiveScaling: false,
              adaptiveThresholds: true
            },
            intelligent: {
              algorithm: 'ml_optimized',
              loadBalancing: true,
              predictiveScaling: true,
              adaptiveThresholds: true
            },
            predictive: {
              algorithm: 'predictive_ml',
              loadBalancing: true,
              predictiveScaling: true,
              adaptiveThresholds: true
            }
          };
          
          const config = distributionConfig[distributionMode];
          console.log(`‚öôÔ∏è Distribution config:`, JSON.stringify(config, null, 2));
          
          // Optimization targets configuration
          const optimizationWeights = {
            speed: { performance: 0.7, reliability: 0.2, cost: 0.1 },
            reliability: { performance: 0.2, reliability: 0.7, cost: 0.1 },
            cost: { performance: 0.2, reliability: 0.2, cost: 0.6 },
            balanced: { performance: 0.4, reliability: 0.4, cost: 0.2 }
          };
          
          const weights = optimizationWeights[optimizationTarget];
          console.log(`üéØ Optimization weights:`, JSON.stringify(weights, null, 2));
          
          // Workload metrics tracking
          const workloadMetrics = {
            currentLoad: {
              totalWorkflows: 0,
              activeWorkflows: 0,
              queuedWorkflows: 0,
              averageWaitTime: 0,
              throughput: 0,
              resourceUtilization: {}
            },
            workflowDistribution: {},
            performanceMetrics: {},
            loadBalancingDecisions: [],
            scalingRecommendations: [],
            optimizationScore: 0,
            distributionEfficiency: 0,
            recommendations: [],
            startTime: startTime
          };
          
          try {
            console.log('\nüìä === PHASE 1: CURRENT WORKLOAD ANALYSIS ===');
            
            // Analyze current workflow load
            const analysisWindow = 2 * 60 * 60 * 1000; // 2 hours
            const analysisStart = new Date(Date.now() - analysisWindow);
            
            console.log(`üîç Analyzing workload from: ${analysisStart.toISOString()}`);
            
            // Get recent workflow runs
            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
              created: `>${analysisStart.toISOString()}`
            });
            
            const runs = workflowRuns.data.workflow_runs;
            workloadMetrics.currentLoad.totalWorkflows = runs.length;
            
            console.log(`üìà Total workflows in analysis window: ${runs.length}`);
            
            // Categorize workflows by status
            const activeRuns = runs.filter(r => r.status === 'in_progress' || r.status === 'queued');
            const queuedRuns = runs.filter(r => r.status === 'queued');
            const completedRuns = runs.filter(r => r.status === 'completed');
            
            workloadMetrics.currentLoad.activeWorkflows = activeRuns.length;
            workloadMetrics.currentLoad.queuedWorkflows = queuedRuns.length;
            workloadMetrics.currentLoad.throughput = completedRuns.length / 2; // per hour
            
            console.log(`üèÉ Active workflows: ${activeRuns.length}`);
            console.log(`‚è≥ Queued workflows: ${queuedRuns.length}`);
            console.log(`‚úÖ Completed workflows: ${completedRuns.length}`);
            console.log(`üöÄ Throughput: ${workloadMetrics.currentLoad.throughput} workflows/hour`);
            
            // Analyze workflow distribution by type
            const workflowTypes = {};
            const workflowPerformance = {};
            
            runs.forEach(run => {
              const workflowName = run.name;
              workflowTypes[workflowName] = (workflowTypes[workflowName] || 0) + 1;
              
              // Calculate execution times for performance analysis
              if (run.run_started_at && run.updated_at && run.status === 'completed') {
                const executionTime = (new Date(run.updated_at) - new Date(run.run_started_at)) / 1000;
                
                if (!workflowPerformance[workflowName]) {
                  workflowPerformance[workflowName] = {
                    executions: 0,
                    totalTime: 0,
                    averageTime: 0,
                    successRate: 0,
                    successCount: 0
                  };
                }
                
                workflowPerformance[workflowName].executions++;
                workflowPerformance[workflowName].totalTime += executionTime;
                workflowPerformance[workflowName].averageTime = 
                  workflowPerformance[workflowName].totalTime / workflowPerformance[workflowName].executions;
                
                if (run.conclusion === 'success') {
                  workflowPerformance[workflowName].successCount++;
                }
                
                workflowPerformance[workflowName].successRate = 
                  (workflowPerformance[workflowName].successCount / workflowPerformance[workflowName].executions) * 100;
              }
            });
            
            workloadMetrics.workflowDistribution = workflowTypes;
            workloadMetrics.performanceMetrics = workflowPerformance;
            
            console.log(`üìä Workflow types: ${Object.keys(workflowTypes).length}`);
            console.log(`üìà Performance metrics collected for: ${Object.keys(workflowPerformance).length} workflow types`);
            
            console.log('\n‚öñÔ∏è === PHASE 2: LOAD BALANCING ANALYSIS ===');
            
            // Analyze load distribution efficiency
            const totalWorkflowExecutions = Object.values(workflowTypes).reduce((a, b) => a + b, 0);
            const workflowTypeCount = Object.keys(workflowTypes).length;
            const idealDistribution = totalWorkflowExecutions / workflowTypeCount;
            
            // Calculate distribution variance
            let distributionVariance = 0;
            Object.values(workflowTypes).forEach(count => {
              distributionVariance += Math.pow(count - idealDistribution, 2);
            });
            distributionVariance /= workflowTypeCount;
            
            workloadMetrics.distributionEfficiency = Math.max(0, 100 - (Math.sqrt(distributionVariance) / idealDistribution * 100));
            
            console.log(`‚öñÔ∏è Distribution efficiency: ${workloadMetrics.distributionEfficiency.toFixed(2)}%`);
            console.log(`üìä Distribution variance: ${distributionVariance.toFixed(2)}`);
            
            // Identify load balancing opportunities
            const loadBalancingDecisions = [];
            
            for (const [workflowName, count] of Object.entries(workflowTypes)) {
              const performance = workflowPerformance[workflowName];
              const loadRatio = count / totalWorkflowExecutions;
              
              if (performance) {
                // High load, low performance workflows
                if (loadRatio > 0.3 && performance.averageTime > 120) {
                  loadBalancingDecisions.push({
                    workflow: workflowName,
                    action: 'scale_out',
                    reason: 'High load with slow execution time',
                    priority: 'high',
                    currentLoad: count,
                    avgTime: performance.averageTime,
                    recommendation: 'Consider parallel execution or resource scaling'
                  });
                }
                
                // High failure rate workflows
                if (performance.successRate < 90 && count > 5) {
                  loadBalancingDecisions.push({
                    workflow: workflowName,
                    action: 'investigate',
                    reason: 'High failure rate affecting load distribution',
                    priority: 'critical',
                    currentLoad: count,
                    successRate: performance.successRate,
                    recommendation: 'Investigate and fix reliability issues'
                  });
                }
                
                // Underutilized efficient workflows
                if (loadRatio < 0.1 && performance.averageTime < 30 && performance.successRate > 95) {
                  loadBalancingDecisions.push({
                    workflow: workflowName,
                    action: 'scale_up',
                    reason: 'Underutilized efficient workflow',
                    priority: 'low',
                    currentLoad: count,
                    efficiency: performance.successRate,
                    recommendation: 'Consider increasing utilization for this efficient workflow'
                  });
                }
              }
            }
            
            workloadMetrics.loadBalancingDecisions = loadBalancingDecisions;
            
            console.log(`‚öñÔ∏è Load balancing decisions: ${loadBalancingDecisions.length}`);
            
            console.log('\nüß† === PHASE 3: INTELLIGENT DISTRIBUTION STRATEGY ===');
            
            // Calculate optimization score based on current performance
            let performanceScore = 0;
            let reliabilityScore = 0;
            let costScore = 0;
            
            const workflowCount = Object.keys(workflowPerformance).length;
            
            if (workflowCount > 0) {
              // Performance score (based on average execution times)
              const avgExecutionTimes = Object.values(workflowPerformance).map(p => p.averageTime);
              const overallAvgTime = avgExecutionTimes.reduce((a, b) => a + b, 0) / avgExecutionTimes.length;
              performanceScore = Math.max(0, 100 - (overallAvgTime / 60 * 20)); // Penalty for slow workflows
              
              // Reliability score (based on success rates)
              const avgSuccessRates = Object.values(workflowPerformance).map(p => p.successRate);
              reliabilityScore = avgSuccessRates.reduce((a, b) => a + b, 0) / avgSuccessRates.length;
              
              // Cost score (simplified - based on efficiency)
              costScore = workloadMetrics.distributionEfficiency;
            }
            
            workloadMetrics.optimizationScore = 
              performanceScore * weights.performance +
              reliabilityScore * weights.reliability +
              costScore * weights.cost;
            
            console.log(`üéØ Performance score: ${performanceScore.toFixed(2)}/100`);
            console.log(`üõ°Ô∏è Reliability score: ${reliabilityScore.toFixed(2)}/100`);
            console.log(`üí∞ Cost score: ${costScore.toFixed(2)}/100`);
            console.log(`üèÜ Overall optimization score: ${workloadMetrics.optimizationScore.toFixed(2)}/100`);
            
            console.log('\nüîÆ === PHASE 4: PREDICTIVE SCALING ANALYSIS ===');
            
            const scalingRecommendations = [];
            
            if (config.predictiveScaling) {
              // Analyze historical patterns for predictive scaling
              const currentHour = new Date().getHours();
              const isBusinessHours = currentHour >= 6 && currentHour <= 18;
              const currentDay = new Date().getDay(); // 0 = Sunday, 6 = Saturday
              const isWeekday = currentDay >= 1 && currentDay <= 5;
              
              // Predict load based on time patterns
              let predictedLoadMultiplier = 1.0;
              
              if (isBusinessHours && isWeekday) {
                predictedLoadMultiplier = 1.5; // 50% higher load during business hours
              } else if (!isBusinessHours && isWeekday) {
                predictedLoadMultiplier = 0.7; // 30% lower load during off-hours
              } else {
                predictedLoadMultiplier = 0.5; // 50% lower load during weekends
              }
              
              const predictedLoad = workloadMetrics.currentLoad.totalWorkflows * predictedLoadMultiplier;
              
              console.log(`üîÆ Predicted load multiplier: ${predictedLoadMultiplier}x`);
              console.log(`üìà Predicted load: ${predictedLoad.toFixed(0)} workflows`);
              
              // Generate scaling recommendations
              if (predictedLoad > workloadMetrics.currentLoad.totalWorkflows * 1.2) {
                scalingRecommendations.push({
                  type: 'scale_up',
                  reason: 'Predicted load increase',
                  targetCapacity: Math.ceil(predictedLoad * 1.1),
                  timeframe: '15 minutes',
                  priority: 'medium'
                });
              } else if (predictedLoad < workloadMetrics.currentLoad.totalWorkflows * 0.8) {
                scalingRecommendations.push({
                  type: 'scale_down',
                  reason: 'Predicted load decrease',
                  targetCapacity: Math.ceil(predictedLoad * 1.1),
                  timeframe: '30 minutes',
                  priority: 'low'
                });
              }
              
              // Resource optimization recommendations
              if (workloadMetrics.distributionEfficiency < 80) {
                scalingRecommendations.push({
                  type: 'optimize_distribution',
                  reason: 'Poor load distribution efficiency',
                  targetEfficiency: 90,
                  timeframe: 'immediate',
                  priority: 'high'
                });
              }
            }
            
            workloadMetrics.scalingRecommendations = scalingRecommendations;
            
            console.log(`üîÆ Scaling recommendations: ${scalingRecommendations.length}`);
            
            console.log('\nüí° === PHASE 5: OPTIMIZATION RECOMMENDATIONS ===');
            
            const recommendations = [];
            
            // Performance optimization recommendations
            if (performanceScore < 80) {
              recommendations.push('üöÄ **Performance**: Optimize slow workflows - consider parallel execution');
              recommendations.push('‚ö° **Caching**: Implement caching for frequently used data');
              recommendations.push('üîß **Optimization**: Review and optimize algorithm efficiency');
            }
            
            // Reliability optimization recommendations
            if (reliabilityScore < 95) {
              recommendations.push('üõ°Ô∏è **Reliability**: Investigate and fix workflow failures');
              recommendations.push('üîÑ **Retry Logic**: Implement better error handling and retry mechanisms');
              recommendations.push('üìä **Monitoring**: Increase monitoring and alerting for failed workflows');
            }
            
            // Cost optimization recommendations
            if (costScore < 85) {
              recommendations.push('üí∞ **Cost**: Optimize resource allocation and distribution');
              recommendations.push('‚öñÔ∏è **Load Balancing**: Implement better load balancing strategies');
              recommendations.push('üìà **Utilization**: Improve resource utilization efficiency');
            }
            
            // Load balancing specific recommendations
            if (workloadMetrics.distributionEfficiency < 80) {
              recommendations.push('‚öñÔ∏è **Distribution**: Rebalance workload distribution across workflow types');
              recommendations.push('üîÑ **Scheduling**: Implement intelligent workflow scheduling');
            }
            
            // General optimization recommendations
            if (workloadMetrics.optimizationScore >= 90) {
              recommendations.push('‚úÖ **Excellent**: System is well-optimized, maintain current configuration');
              recommendations.push('üìä **Monitoring**: Continue monitoring for potential improvements');
            } else if (workloadMetrics.optimizationScore >= 80) {
              recommendations.push('üü° **Good**: Minor optimizations possible');
              recommendations.push('üîç **Analysis**: Review specific workflow performance metrics');
            } else {
              recommendations.push('üî¥ **Critical**: Significant optimization needed');
              recommendations.push('üö® **Immediate**: Implement performance improvements immediately');
            }
            
            workloadMetrics.recommendations = recommendations;
            
            console.log('\nüìã === PHASE 6: DISTRIBUTION REPORT GENERATION ===');
            
            const executionTime = Math.round((Date.now() - startTime) / 1000);
            const distributionGrade = workloadMetrics.optimizationScore >= 95 ? 'A+' :
                                   workloadMetrics.optimizationScore >= 90 ? 'A' :
                                   workloadMetrics.optimizationScore >= 80 ? 'B+' :
                                   workloadMetrics.optimizationScore >= 70 ? 'B' :
                                   workloadMetrics.optimizationScore >= 60 ? 'C' : 'F';
            
            // Generate comprehensive distribution report
            const distributionReport = `## ‚öñÔ∏è Intelligent Workload Distribution Report

### üéØ Distribution Summary
**Optimization Grade**: ${getDistributionEmoji(distributionGrade)} **${distributionGrade}** (${workloadMetrics.optimizationScore.toFixed(1)}/100)
**Distribution Mode**: ${distributionMode.toUpperCase()}
**Optimization Target**: ${optimizationTarget.toUpperCase()}
**Distribution Efficiency**: ${workloadMetrics.distributionEfficiency.toFixed(1)}%
**Execution ID**: \`${executionId}\`
**Analysis Time**: ${executionTime}s

### üìä Current Workload Metrics
| Metric | Value | Status |
|--------|-------|--------|
| üöÄ **Total Workflows** | ${workloadMetrics.currentLoad.totalWorkflows} | üìä |
| üèÉ **Active Workflows** | ${workloadMetrics.currentLoad.activeWorkflows} | ${workloadMetrics.currentLoad.activeWorkflows > 10 ? '‚ö†Ô∏è' : '‚úÖ'} |
| ‚è≥ **Queued Workflows** | ${workloadMetrics.currentLoad.queuedWorkflows} | ${workloadMetrics.currentLoad.queuedWorkflows > 5 ? '‚ö†Ô∏è' : '‚úÖ'} |
| üìà **Throughput** | ${workloadMetrics.currentLoad.throughput.toFixed(1)}/h | ${workloadMetrics.currentLoad.throughput > 20 ? '‚úÖ' : '‚ö†Ô∏è'} |
| ‚öñÔ∏è **Distribution Efficiency** | ${workloadMetrics.distributionEfficiency.toFixed(1)}% | ${workloadMetrics.distributionEfficiency >= 80 ? '‚úÖ' : workloadMetrics.distributionEfficiency >= 60 ? '‚ö†Ô∏è' : '‚ùå'} |

### üéØ Optimization Scores
- **Performance Score**: ${performanceScore.toFixed(1)}/100 (Weight: ${(weights.performance * 100).toFixed(0)}%)
- **Reliability Score**: ${reliabilityScore.toFixed(1)}/100 (Weight: ${(weights.reliability * 100).toFixed(0)}%)
- **Cost Efficiency**: ${costScore.toFixed(1)}/100 (Weight: ${(weights.cost * 100).toFixed(0)}%)
- **Overall Score**: ${workloadMetrics.optimizationScore.toFixed(1)}/100

### üìä Workflow Distribution Analysis
${Object.entries(workloadMetrics.workflowDistribution)
  .sort(([,a], [,b]) => b - a)
  .slice(0, 8)
  .map(([workflow, count]) => {
    const percentage = (count / workloadMetrics.currentLoad.totalWorkflows * 100).toFixed(1);
    const performance = workloadMetrics.performanceMetrics[workflow];
    return `- **${workflow}**: ${count} executions (${percentage}%)${performance ? ` - Avg: ${performance.averageTime.toFixed(1)}s, Success: ${performance.successRate.toFixed(1)}%` : ''}`;
  }).join('\n')}

${workloadMetrics.loadBalancingDecisions.length > 0 ? `### ‚öñÔ∏è Load Balancing Decisions
${workloadMetrics.loadBalancingDecisions
  .sort((a, b) => (b.priority === 'critical' ? 2 : b.priority === 'high' ? 1 : 0) - (a.priority === 'critical' ? 2 : a.priority === 'high' ? 1 : 0))
  .slice(0, 5)
  .map(decision => 
    `#### ${decision.priority === 'critical' ? 'üö®' : decision.priority === 'high' ? '‚ö†Ô∏è' : 'üîµ'} ${decision.workflow} - ${decision.action.toUpperCase()}
**Reason**: ${decision.reason}
**Priority**: ${decision.priority.toUpperCase()}
**Recommendation**: ${decision.recommendation}
${decision.avgTime ? `**Avg Time**: ${decision.avgTime.toFixed(1)}s` : ''}
${decision.successRate ? `**Success Rate**: ${decision.successRate.toFixed(1)}%` : ''}`
  ).join('\n\n')}
` : '### ‚úÖ Load Balancing Status\n- No immediate load balancing actions required\n- System load distribution is optimal'}

${workloadMetrics.scalingRecommendations.length > 0 ? `### üîÆ Predictive Scaling Recommendations
${workloadMetrics.scalingRecommendations.map(rec => 
  `- **${rec.type.toUpperCase()}** (${rec.priority.toUpperCase()}): ${rec.reason}
  - **Target**: ${rec.targetCapacity || rec.targetEfficiency || 'Optimize'}
  - **Timeframe**: ${rec.timeframe}
  - **Impact**: ${rec.type.includes('scale') ? 'Capacity adjustment' : 'Efficiency improvement'}`
).join('\n')}
` : '### ‚úÖ Scaling Status\n- Current capacity is optimal for predicted load\n- No scaling actions required at this time'}

### üí° Optimization Recommendations
${recommendations.map(rec => `- ${rec}`).join('\n')}

### üìà Performance Insights
${Object.keys(workloadMetrics.performanceMetrics).length > 0 ? `
**Top Performing Workflows:**
${Object.entries(workloadMetrics.performanceMetrics)
  .sort(([,a], [,b]) => (b.successRate - a.successRate) + ((60 - a.averageTime) - (60 - b.averageTime)) * 0.1)
  .slice(0, 3)
  .map(([workflow, perf]) => `- **${workflow}**: ${perf.successRate.toFixed(1)}% success, ${perf.averageTime.toFixed(1)}s avg`)
  .join('\n')}

**Workflows Needing Attention:**
${Object.entries(workloadMetrics.performanceMetrics)
  .sort(([,a], [,b]) => (a.successRate - b.successRate) + (a.averageTime - b.averageTime) * 0.1)
  .slice(0, 3)
  .map(([workflow, perf]) => `- **${workflow}**: ${perf.successRate.toFixed(1)}% success, ${perf.averageTime.toFixed(1)}s avg`)
  .join('\n')}
` : '- Insufficient performance data for detailed analysis'}

### üéØ Distribution Strategy
**Current Strategy**: ${distributionMode} mode with ${optimizationTarget} optimization
**Algorithm**: ${config.algorithm}
**Features**:
- Load Balancing: ${config.loadBalancing ? '‚úÖ Enabled' : '‚ùå Disabled'}
- Predictive Scaling: ${config.predictiveScaling ? '‚úÖ Enabled' : '‚ùå Disabled'}
- Adaptive Thresholds: ${config.adaptiveThresholds ? '‚úÖ Enabled' : '‚ùå Disabled'}

### ‚è∞ Next Distribution Cycle
**Schedule**: Every 15 minutes (business hours) / 30 minutes (off-hours)
**Mode**: ${distributionMode} (adjustable via workflow_dispatch)
**Target**: ${optimizationTarget} optimization (adjustable via workflow_dispatch)

---
‚öñÔ∏è **Intelligent Workload Distribution** | **${distributionMode.toUpperCase()} Mode** | **Load Balancing**
üß† **ML-Optimized** | **Predictive Scaling** | **Adaptive Distribution**`;

            // Post distribution report
            const reportIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `‚öñÔ∏è Workload Distribution Report - ${distributionGrade} Grade - ${timestamp}`,
              body: distributionReport,
              labels: [
                'workload-distribution',
                'load-balancing',
                `grade-${distributionGrade.toLowerCase().replace('+', '-plus')}`,
                `mode-${distributionMode}`,
                `target-${optimizationTarget}`,
                workloadMetrics.optimizationScore >= 80 ? 'well-optimized' : 'needs-optimization'
              ]
            });
            
            // Create optimization alert if needed
            if (workloadMetrics.optimizationScore < 70 || workloadMetrics.distributionEfficiency < 60) {
              const optimizationAlert = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `‚ö†Ô∏è Workload Distribution Alert - Optimization Required`,
                body: `## ‚ö†Ô∏è WORKLOAD DISTRIBUTION OPTIMIZATION ALERT

**Alert Level**: ${workloadMetrics.optimizationScore < 50 ? 'CRITICAL' : 'WARNING'}
**Optimization Score**: ${workloadMetrics.optimizationScore.toFixed(1)}/100
**Distribution Efficiency**: ${workloadMetrics.distributionEfficiency.toFixed(1)}%
**Impact**: Reduced system efficiency and performance

### üìä Key Issues
- **Performance Score**: ${performanceScore.toFixed(1)}/100
- **Reliability Score**: ${reliabilityScore.toFixed(1)}/100
- **Cost Efficiency**: ${costScore.toFixed(1)}/100
- **Distribution Efficiency**: ${workloadMetrics.distributionEfficiency.toFixed(1)}%

### üö® Critical Load Balancing Decisions
${workloadMetrics.loadBalancingDecisions
  .filter(d => d.priority === 'critical' || d.priority === 'high')
  .slice(0, 3)
  .map(decision => `- **${decision.workflow}**: ${decision.reason} (${decision.action})`)
  .join('\n') || '- No critical decisions pending'}

### ‚ö° Immediate Actions Required
1. üîç **Review**: Analyze workflow performance and distribution patterns
2. ‚öñÔ∏è **Rebalance**: Implement load balancing recommendations
3. üöÄ **Optimize**: Address performance bottlenecks
4. üìä **Monitor**: Increase monitoring frequency

### üí° Quick Fixes
${recommendations.filter(r => r.includes('**Performance**') || r.includes('**Distribution**')).slice(0, 3).join('\n') || '- Review detailed recommendations in main report'}

---
‚ö†Ô∏è **Workload Distribution Alert** | **Optimization Required** | **Performance Impact**`,
                labels: ['workload-alert', 'optimization-required', workloadMetrics.optimizationScore < 50 ? 'critical' : 'warning', 'load-balancing']
              });
              
              console.log(`‚ö†Ô∏è WORKLOAD OPTIMIZATION ALERT ISSUED: #${optimizationAlert.data.number}`);
            }
            
            console.log(`‚úÖ CLAUDE WORKLOAD DISTRIBUTION ENGINE COMPLETED`);
            console.log(`‚öñÔ∏è Distribution Grade: ${distributionGrade} (${workloadMetrics.optimizationScore.toFixed(1)}/100)`);
            console.log(`üìä Efficiency: ${workloadMetrics.distributionEfficiency.toFixed(1)}%`);
            console.log(`üéØ Load Balancing Decisions: ${workloadMetrics.loadBalancingDecisions.length}`);
            console.log(`‚ö° Execution Time: ${executionTime}s`);
            
          } catch (error) {
            console.log(`‚ùå Workload Distribution Engine Error: ${error.message}`);
            
            // Create error alert
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `‚ùå Workload Distribution System Error - ${timestamp}`,
              body: `## ‚ùå Workload Distribution System Error

The Claude Intelligent Workload Distribution Engine encountered a critical error and could not complete the analysis.

**Error Details:**
- **Message**: ${error.message}
- **Execution ID**: \`${executionId}\`
- **Distribution Mode**: ${distributionMode}
- **Optimization Target**: ${optimizationTarget}

**Impact:**
- Workload distribution optimization temporarily unavailable
- Load balancing decisions may be delayed
- Manual workload management recommended

**Recovery Actions:**
1. Review workload distribution workflow configuration
2. Verify system permissions and API access
3. Check resource availability and monitoring systems
4. Implement manual load balancing if needed

**Error Context:**
\`\`\`
${error.stack}
\`\`\`

---
‚ùå **Workload Distribution Error** | **Load Balancing Disrupted** | **Manual Management Required**`,
              labels: ['workload-distribution-error', 'system-failure', 'load-balancing-down', 'urgent']
            });
            
            throw error;
          }
          
          // Helper function
          function getDistributionEmoji(grade) {
            const emojis = {
              'A+': 'üèÜ',
              'A': '‚öñÔ∏è',
              'B+': 'üìä',
              'B': 'üìà',
              'C': '‚ö†Ô∏è',
              'F': '‚ùå'
            };
            return emojis[grade] || 'üìä';
          }