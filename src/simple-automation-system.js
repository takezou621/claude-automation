/**
 * Simple Automation System
 * ç„¡æ–™ã§ä½¿ãˆã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãªGitHubè‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ 
 */

const winston = require('winston');
const ClaudeAPIClient = require('./claude-api-client');
const GitHubClient = require('./github-client');

class SimpleAutomationSystem {
  constructor(config = {}) {
    this.config = {
      github: {
        token: config.github?.token || process.env.GITHUB_TOKEN,
        owner: config.github?.owner,
        repo: config.github?.repo
      },
      claude: {
        apiKey: config.claude?.apiKey || process.env.CLAUDE_API_KEY,
        model: config.claude?.model || 'claude-3-haiku-20240307' // å®‰ä¾¡ãªãƒ¢ãƒ‡ãƒ«
      },
      automation: {
        autoReview: config.automation?.autoReview || true,
        autoLabel: config.automation?.autoLabel || true,
        autoAssign: config.automation?.autoAssign || false
      }
    };
    
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.simple(),
      transports: [new winston.transports.Console()]
    });
    
    this.claudeClient = new ClaudeAPIClient(this.config.claude.apiKey, {
      model: this.config.claude.model,
      maxTokens: 1000, // ã‚³ã‚¹ãƒˆã‚’æŠ‘åˆ¶
      temperature: 0.1
    });
    
    this.githubClient = new GitHubClient(this.config.github);
    
    this.stats = {
      processedPRs: 0,
      processedIssues: 0,
      errors: 0,
      startTime: new Date()
    };
  }

  /**
   * ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆç„¡æ–™ç‰ˆï¼‰
   */
  async reviewPullRequest(prNumber) {
    try {
      // GitHubã‹ã‚‰PRãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const prResult = await this.githubClient.getPullRequest(prNumber);
      if (!prResult.success) {
        throw new Error(`Failed to get PR: ${prResult.error}`);
      }
      
      const prData = prResult.data;
      
      // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§ã‚³ã‚¹ãƒˆã‚’æŠ‘åˆ¶
      const prompt = `ç°¡æ½”ã«ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ãã ã•ã„ï¼š

ã‚¿ã‚¤ãƒˆãƒ«: ${prData.title}
å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${prData.files?.length || 0}
ä¸»ãªå¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«: ${prData.files?.slice(0, 3).map(f => f.filename).join(', ') || 'ãªã—'}

ä¸»ãªå¤‰æ›´ç‚¹ã‚’3ã¤ã¾ã§ã®ãƒã‚¤ãƒ³ãƒˆã§è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚`;
      
      const response = await this.claudeClient.sendMessage(prompt, {
        maxTokens: 500 // ã•ã‚‰ã«ã‚³ã‚¹ãƒˆã‚’æŠ‘åˆ¶
      });
      
      if (response.success) {
        // ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’PRã«æŠ•ç¨¿
        const reviewComment = `## ğŸ¤– AI Code Review

${response.response}

---
*This review was generated by Claude AI automation (Free Tier)*`;
        
        const commentResult = await this.githubClient.createPullRequestComment(prNumber, reviewComment);
        
        // ai-reviewedãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
        await this.githubClient.addLabelsToIssue(prNumber, ['ai-reviewed']);
        
        this.stats.processedPRs++;
        return {
          success: true,
          review: response.response,
          commentPosted: commentResult.success,
          cost: 'low'
        };
      }
      
      throw new Error(response.error);
      
    } catch (error) {
      this.stats.errors++;
      this.logger.error('PR review failed:', error.message);
      
      // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼å¿…è¦ã®ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
      await this.githubClient.addLabelsToIssue(prNumber, ['needs-human-review']);
      
      return {
        success: false,
        error: error.message,
        fallback: 'ã“ã®PRã¯æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ã§ã™ã€‚'
      };
    }
  }

  /**
   * ã‚¤ã‚·ãƒ¥ãƒ¼ã®è‡ªå‹•åˆ†é¡ï¼ˆç„¡æ–™ç‰ˆï¼‰
   */
  async classifyIssue(issueNumber) {
    try {
      // GitHubã‹ã‚‰ã‚¤ã‚·ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const issueResult = await this.githubClient.getIssue(issueNumber);
      if (!issueResult.success) {
        throw new Error(`Failed to get issue: ${issueResult.error}`);
      }
      
      const issueData = issueResult.data;
      
      const prompt = `ã“ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’1ã¤ã®ã‚«ãƒ†ã‚´ãƒªã«åˆ†é¡ã—ã¦ãã ã•ã„ï¼š

ã‚¿ã‚¤ãƒˆãƒ«: ${issueData.title}
æœ¬æ–‡: ${issueData.body?.substring(0, 200) || ''}

ã‚«ãƒ†ã‚´ãƒª: bug, feature, documentation, question ã®ã„ãšã‚Œã‹1ã¤ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚`;
      
      const response = await this.claudeClient.sendMessage(prompt, {
        maxTokens: 50
      });
      
      if (response.success) {
        const category = response.response.toLowerCase().trim();
        const validCategory = ['bug', 'feature', 'documentation', 'question'].includes(category) ? category : 'question';
        
        // åˆ†é¡çµæœã«åŸºã¥ã„ã¦ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
        const labels = [`auto-${validCategory}`, 'ai-classified'];
        await this.githubClient.addLabelsToIssue(issueNumber, labels);
        
        this.stats.processedIssues++;
        return {
          success: true,
          category: validCategory,
          labelsAdded: labels,
          cost: 'minimal'
        };
      }
      
      throw new Error(response.error);
      
    } catch (error) {
      this.stats.errors++;
      this.logger.error('Issue classification failed:', error.message);
      
      // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
      await this.githubClient.addLabelsToIssue(issueNumber, ['auto-question', 'needs-human-review']);
      
      return {
        success: false,
        error: error.message,
        fallback: 'question' // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ†ã‚´ãƒª
      };
    }
  }

  /**
   * åŸºæœ¬çš„ãªè‡ªå‹•åŒ–å‡¦ç†
   */
  async processGitHubEvent(eventType, eventData) {
    this.logger.info(`Processing ${eventType} event`);
    
    switch (eventType) {
      case 'pull_request':
        if (this.config.automation.autoReview) {
          return await this.reviewPullRequest(eventData.number);
        }
        break;
        
      case 'issues':
        if (this.config.automation.autoLabel) {
          return await this.classifyIssue(eventData.number);
        }
        break;
        
      default:
        this.logger.info(`Event type ${eventType} not handled`);
        return { success: false, reason: 'Event type not supported' };
    }
  }

  /**
   * è¤‡æ•°ã®PRã‚’ä¸€æ‹¬å‡¦ç†
   */
  async processPendingPRs() {
    try {
      const recentPRs = await this.githubClient.getRecentPullRequests(5);
      if (!recentPRs.success) {
        throw new Error(`Failed to get recent PRs: ${recentPRs.error}`);
      }
      
      const results = [];
      for (const pr of recentPRs.data) {
        this.logger.info(`Processing PR #${pr.number}: ${pr.title}`);
        
        try {
          const result = await this.reviewPullRequest(pr.number);
          results.push({
            prNumber: pr.number,
            title: pr.title,
            ...result
          });
          
          // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’è€ƒæ…®ã—ã¦å°‘ã—å¾…æ©Ÿ
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          results.push({
            prNumber: pr.number,
            title: pr.title,
            success: false,
            error: error.message
          });
        }
      }
      
      return {
        success: true,
        processed: results.length,
        results
      };
      
    } catch (error) {
      this.logger.error('Failed to process pending PRs:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * è¤‡æ•°ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’ä¸€æ‹¬å‡¦ç†
   */
  async processPendingIssues() {
    try {
      const recentIssues = await this.githubClient.getRecentIssues(5);
      if (!recentIssues.success) {
        throw new Error(`Failed to get recent issues: ${recentIssues.error}`);
      }
      
      const results = [];
      for (const issue of recentIssues.data) {
        this.logger.info(`Processing Issue #${issue.number}: ${issue.title}`);
        
        try {
          const result = await this.classifyIssue(issue.number);
          results.push({
            issueNumber: issue.number,
            title: issue.title,
            ...result
          });
          
          // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’è€ƒæ…®ã—ã¦å°‘ã—å¾…æ©Ÿ
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          results.push({
            issueNumber: issue.number,
            title: issue.title,
            success: false,
            error: error.message
          });
        }
      }
      
      return {
        success: true,
        processed: results.length,
        results
      };
      
    } catch (error) {
      this.logger.error('Failed to process pending issues:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   */
  async initialize() {
    try {
      this.logger.info('Initializing Simple Automation System...');
      
      // GitHubæ¥ç¶šãƒ†ã‚¹ãƒˆ
      const githubHealth = await this.githubClient.healthCheck();
      if (!githubHealth.status === 'healthy') {
        throw new Error('GitHub connection failed');
      }
      
      // Claudeæ¥ç¶šãƒ†ã‚¹ãƒˆ
      const claudeTest = await this.claudeClient.testConnection();
      if (!claudeTest.success) {
        throw new Error('Claude connection failed');
      }
      
      // åŸºæœ¬ãƒ©ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      await this.githubClient.setupBasicLabels();
      
      this.logger.info('Simple Automation System initialized successfully');
      
      return {
        success: true,
        github: githubHealth,
        claude: claudeTest.success
      };
      
    } catch (error) {
      this.logger.error('Initialization failed:', error.message);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã®å–å¾—
   */
  getStats() {
    return {
      ...this.stats,
      uptime: process.uptime(),
      timestamp: new Date().toISOString()
    };
  }

  /**
   * è¨­å®šã®æ›´æ–°
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.logger.info('Configuration updated');
  }

  /**
   * ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
   */
  async healthCheck() {
    try {
      // GitHub APIã®ãƒ†ã‚¹ãƒˆ
      const githubHealth = await this.githubClient.healthCheck();
      
      // Claude APIã®ç°¡å˜ãªãƒ†ã‚¹ãƒˆ
      const claudeTest = await this.claudeClient.sendMessage('test', {
        maxTokens: 10
      });
      
      return {
        status: githubHealth.status === 'healthy' && claudeTest.success ? 'healthy' : 'unhealthy',
        github: githubHealth,
        claude: claudeTest.success,
        stats: this.getStats(),
        rateLimit: githubHealth.rateLimit
      };
      
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        stats: this.getStats()
      };
    }
  }
}

module.exports = SimpleAutomationSystem;