/**
 * Performance Analytics Manager
 *
 * Comprehensive monitoring and analytics for all automation tiers with
 * real-time tracking, tier comparison, and anomaly detection.
 *
 * Generated by Claude Smart Automation
 */

class PerformanceAnalyticsManager {
  constructor (configManager, options = {}) {
    this.configManager = configManager;
    
    // Get configuration from ConfigManager or use defaults
    const performanceConfig = this.configManager ? 
      this.configManager.getPerformanceTrackingConfig() : {};
    
    this.retentionDays = options.retentionDays || performanceConfig.retentionDays || 30;
    this.anomalyThreshold = options.anomalyThreshold || performanceConfig.anomalyThreshold || 2.0;
    this.alertingEnabled = options.alertingEnabled !== false && (performanceConfig.alerting !== false);
    this.metrics = new Map();
    this.alerts = [];
    this.maxMetricsPerTier = options.maxMetricsPerTier || 10000; // Prevent memory leaks
    this.maxAlertsCount = options.maxAlertsCount || 1000;
    this.baselines = this.initializeBaselines();
    this.aggregationIntervals = ['1m', '5m', '15m', '1h', '1d'];
    
    // Start automatic cleanup intervals
    this.startCleanupIntervals();
  }

  /**
   * Start automatic cleanup intervals to prevent memory leaks
   */
  startCleanupIntervals() {
    // Cleanup old metrics every hour
    this.metricsCleanupInterval = setInterval(() => {
      this.cleanupOldMetrics();
    }, 60 * 60 * 1000); // 1 hour

    // Cleanup old alerts every 30 minutes
    this.alertsCleanupInterval = setInterval(() => {
      this.cleanupOldAlerts();
    }, 30 * 60 * 1000); // 30 minutes
  }

  /**
   * Clean up old metrics based on retention policy and size limits
   */
  cleanupOldMetrics() {
    const cutoffTime = Date.now() - (this.retentionDays * 24 * 60 * 60 * 1000);
    
    for (const [tier, tierMetrics] of this.metrics.entries()) {
      if (tierMetrics.raw) {
        // Remove old metrics based on time
        tierMetrics.raw = tierMetrics.raw.filter(metric => metric.timestamp > cutoffTime);
        
        // Also enforce size limits to prevent unbounded growth
        if (tierMetrics.raw.length > this.maxMetricsPerTier) {
          tierMetrics.raw = tierMetrics.raw.slice(-this.maxMetricsPerTier);
        }
        
        console.log(`ðŸ§¹ Cleaned up ${tier} tier metrics. Remaining: ${tierMetrics.raw.length}`);
      }
    }
  }

  /**
   * Clean up old alerts to prevent memory leaks
   */
  cleanupOldAlerts() {
    if (this.alerts.length > this.maxAlertsCount) {
      const removedCount = this.alerts.length - this.maxAlertsCount;
      this.alerts = this.alerts.slice(-this.maxAlertsCount);
      console.log(`ðŸ§¹ Cleaned up ${removedCount} old alerts. Remaining: ${this.alerts.length}`);
    }
  }

  /**
   * Cleanup intervals when shutting down
   */
  shutdown() {
    if (this.metricsCleanupInterval) {
      clearInterval(this.metricsCleanupInterval);
    }
    if (this.alertsCleanupInterval) {
      clearInterval(this.alertsCleanupInterval);
    }
  }

  /**
     * Initialize performance baselines for each tier from ConfigManager
     */
  initializeBaselines () {
    const defaults = {
      ultimate: {
        executionTime: { mean: 35000, stdDev: 8000, target: 45000 },
        successRate: { mean: 0.92, stdDev: 0.05, target: 0.90 },
        resourceUsage: { mean: 25, stdDev: 10, target: 50 },
        apiCalls: { mean: 15, stdDev: 5, target: 30 },
        throughput: { mean: 1440, stdDev: 50, target: 1200 } // executions per day
      },
      rapid: {
        executionTime: { mean: 180000, stdDev: 30000, target: 240000 },
        successRate: { mean: 0.88, stdDev: 0.08, target: 0.85 },
        resourceUsage: { mean: 45, stdDev: 15, target: 70 },
        apiCalls: { mean: 35, stdDev: 10, target: 60 },
        throughput: { mean: 288, stdDev: 20, target: 240 }
      },
      smart: {
        executionTime: { mean: 600000, stdDev: 120000, target: 900000 },
        successRate: { mean: 0.95, stdDev: 0.03, target: 0.93 },
        resourceUsage: { mean: 70, stdDev: 20, target: 90 },
        apiCalls: { mean: 80, stdDev: 20, target: 120 },
        throughput: { mean: 21, stdDev: 3, target: 18 }
      }
    };

    if (!this.configManager) {
      return defaults;
    }

    // Try to get baselines from ConfigManager's learning data or tier configs
    const baselines = {};
    for (const tier of ['ultimate', 'rapid', 'smart']) {
      const tierConfig = this.configManager.getTierConfig(tier);
      const configBaselines = this.configManager.get(`performance.baselines.${tier}`, {});
      
      baselines[tier] = {
        executionTime: {
          ...defaults[tier].executionTime,
          target: tierConfig ? tierConfig.maxExecutionTime : defaults[tier].executionTime.target,
          ...configBaselines.executionTime
        },
        successRate: {
          ...defaults[tier].successRate,
          ...configBaselines.successRate
        },
        resourceUsage: {
          ...defaults[tier].resourceUsage,
          target: tierConfig ? tierConfig.resourceLimits?.cpu || defaults[tier].resourceUsage.target : defaults[tier].resourceUsage.target,
          ...configBaselines.resourceUsage
        },
        apiCalls: {
          ...defaults[tier].apiCalls,
          target: tierConfig ? tierConfig.resourceLimits?.apiCalls || defaults[tier].apiCalls.target : defaults[tier].apiCalls.target,
          ...configBaselines.apiCalls
        },
        throughput: {
          ...defaults[tier].throughput,
          ...configBaselines.throughput
        }
      };
    }

    return baselines;
  }

  /**
     * Record performance metrics for a tier execution
     * @param {string} tier - Automation tier (ultimate, rapid, smart)
     * @param {Object} metrics - Execution metrics
     * @returns {Object} Recording result with analysis
     */
  recordExecution (tier, metrics) {
    // Input validation
    if (!tier || typeof tier !== 'string') {
      throw new Error('Invalid tier parameter: must be a non-empty string');
    }
    
    if (!metrics || typeof metrics !== 'object') {
      throw new Error('Invalid metrics parameter: must be an object');
    }
    
    if (typeof metrics.executionTime !== 'number' || metrics.executionTime < 0) {
      throw new Error('Invalid executionTime: must be a non-negative number');
    }
    
    if (typeof metrics.success !== 'boolean') {
      throw new Error('Invalid success parameter: must be a boolean');
    }
    
    // Validate tier is one of the expected values
    const validTiers = ['ultimate', 'rapid', 'smart'];
    if (!validTiers.includes(tier)) {
      console.warn(`Warning: Unexpected tier value '${tier}'. Expected one of: ${validTiers.join(', ')}`);
    }

    const timestamp = Date.now();
    const metricId = this.generateMetricId(tier, timestamp);

    const processedMetrics = {
      id: metricId,
      tier,
      timestamp,
      executionTime: metrics.executionTime,
      success: metrics.success,
      errorMessage: metrics.errorMessage || null,
      resourceUsage: {
        cpu: metrics.cpu || 0,
        memory: metrics.memory || 0,
        apiCalls: metrics.apiCalls || 0,
        networkLatency: metrics.networkLatency || 0
      },
      qualityMetrics: {
        issuesProcessed: metrics.issuesProcessed || 0,
        linesChanged: metrics.linesChanged || 0,
        filesModified: metrics.filesModified || 0,
        testsAdded: metrics.testsAdded || 0
      },
      context: {
        issueNumber: metrics.issueNumber,
        issueType: metrics.issueType,
        complexity: metrics.complexity,
        fallbackFrom: metrics.fallbackFrom || null
      }
    };

    // Store the metrics
    this.storeMetrics(processedMetrics);

    // Perform real-time analysis
    const analysis = this.analyzeExecution(tier, processedMetrics);

    // Check for anomalies
    const anomalies = this.detectAnomalies(tier, processedMetrics);
    if (anomalies.length > 0) {
      this.handleAnomalies(tier, anomalies, processedMetrics);
    }

    return {
      recorded: true,
      metricId,
      analysis,
      anomalies,
      recommendations: this.generateRecommendations(tier, analysis, anomalies)
    };
  }

  /**
     * Store metrics with appropriate aggregation
     */
  storeMetrics (metrics) {
    const tierKey = metrics.tier;

    if (!this.metrics.has(tierKey)) {
      this.metrics.set(tierKey, {
        raw: [],
        aggregated: new Map()
      });
    }

    const tierMetrics = this.metrics.get(tierKey);

    // Store raw metrics locally
    tierMetrics.raw.push(metrics);

    // Store metrics in ConfigManager for persistence and learning
    if (this.configManager) {
      this.configManager.storePerformanceMetrics(tierKey, {
        executionTime: metrics.executionTime,
        success: metrics.success,
        cpu: metrics.resourceUsage?.cpu,
        memory: metrics.resourceUsage?.memory,
        apiCalls: metrics.apiCalls,
        timestamp: metrics.timestamp
      }).catch(error => {
        console.warn(`Failed to store metrics in ConfigManager: ${error.message}`);
      });
    }

    // Cleanup old metrics
    this.cleanupOldMetrics(tierMetrics);

    // Update aggregated metrics
    this.updateAggregatedMetrics(tierKey, metrics);
  }

  /**
     * Generate unique metric ID
     */
  generateMetricId (tier, timestamp) {
    return `${tier}_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
     * Analyze individual execution
     */
  analyzeExecution (tier, metrics) {
    const baseline = this.baselines[tier];

    const analysis = {
      performance: this.analyzePerformance(metrics, baseline),
      efficiency: this.analyzeEfficiency(metrics, baseline),
      quality: this.analyzeQuality(metrics),
      trend: this.analyzeTrend(tier, metrics),
      score: 0
    };

    // Calculate overall score (0-100)
    analysis.score = this.calculatePerformanceScore(analysis);

    return analysis;
  }

  /**
     * Analyze performance against baseline
     */
  analyzePerformance (metrics, baseline) {
    const executionRatio = metrics.executionTime / baseline.executionTime.target;
    const successRating = metrics.success ? 1.0 : 0.0;

    return {
      executionTimeRatio: executionRatio,
      executionTimeStatus: this.getPerformanceStatus(executionRatio, [0.8, 1.0, 1.2]),
      successRate: successRating,
      withinSLA: metrics.executionTime <= baseline.executionTime.target,
      deviation: {
        execution: (metrics.executionTime - baseline.executionTime.mean) / baseline.executionTime.stdDev,
        success: metrics.success ? 0 : -1
      }
    };
  }

  /**
     * Analyze resource efficiency
     */
  analyzeEfficiency (metrics, baseline) {
    const resourceScore = this.calculateResourceScore(metrics.resourceUsage);
    const throughputEstimate = this.estimateThroughput(metrics);

    return {
      resourceScore,
      cpuEfficiency: this.calculateEfficiency(metrics.resourceUsage.cpu, baseline.resourceUsage.mean),
      memoryEfficiency: this.calculateEfficiency(metrics.resourceUsage.memory, baseline.resourceUsage.mean),
      apiEfficiency: this.calculateEfficiency(metrics.resourceUsage.apiCalls, baseline.apiCalls.mean),
      throughputEstimate,
      costPerExecution: this.estimateCost(metrics)
    };
  }

  /**
     * Analyze quality metrics
     */
  analyzeQuality (metrics) {
    const quality = metrics.qualityMetrics;

    return {
      productivity: quality.issuesProcessed > 0 ? 1.0 : 0.0,
      codeImpact: this.calculateCodeImpact(quality),
      testCoverage: quality.testsAdded > 0 ? 1.0 : 0.5,
      comprehensiveness: this.calculateComprehensiveness(quality),
      qualityScore: this.calculateQualityScore(quality)
    };
  }

  /**
     * Analyze trend compared to recent executions
     */
  analyzeTrend (tier, currentMetrics) {
    const recentMetrics = this.getRecentMetrics(tier, 10); // Last 10 executions

    if (recentMetrics.length < 3) {
      return { trend: 'insufficient_data', confidence: 0 };
    }

    const trends = {
      executionTime: this.calculateTrend(recentMetrics.map(m => m.executionTime)),
      successRate: this.calculateTrend(recentMetrics.map(m => m.success ? 1 : 0)),
      resourceUsage: this.calculateTrend(recentMetrics.map(m => m.resourceUsage.cpu))
    };

    return {
      executionTime: trends.executionTime,
      successRate: trends.successRate,
      resourceUsage: trends.resourceUsage,
      overall: this.determineTrendDirection(trends),
      confidence: this.calculateTrendConfidence(trends)
    };
  }

  /**
     * Calculate overall performance score
     */
  calculatePerformanceScore (analysis) {
    const weights = {
      performance: 0.4,
      efficiency: 0.3,
      quality: 0.3
    };

    const performanceScore = analysis.performance.withinSLA
      ? (analysis.performance.successRate * 100)
      : (analysis.performance.successRate * 50);

    const efficiencyScore = analysis.efficiency.resourceScore;
    const qualityScore = analysis.quality.qualityScore;

    return Math.round(
      performanceScore * weights.performance +
            efficiencyScore * weights.efficiency +
            qualityScore * weights.quality
    );
  }

  /**
     * Detect performance anomalies
     * @param {string} tier - Automation tier
     * @param {Object} metrics - Current metrics
     * @returns {Array} List of detected anomalies
     */
  detectAnomalies (tier, metrics) {
    const baseline = this.baselines[tier];
    const anomalies = [];

    // Execution time anomaly
    const executionDeviation = Math.abs(
      (metrics.executionTime - baseline.executionTime.mean) / baseline.executionTime.stdDev
    );

    if (executionDeviation > this.anomalyThreshold) {
      anomalies.push({
        type: 'execution_time',
        severity: executionDeviation > 3 ? 'critical' : 'warning',
        value: metrics.executionTime,
        expected: baseline.executionTime.mean,
        deviation: executionDeviation,
        message: `Execution time ${metrics.executionTime}ms is ${executionDeviation.toFixed(1)} standard deviations from baseline`
      });
    }

    // Resource usage anomaly
    const resourceDeviation = Math.abs(
      (metrics.resourceUsage.cpu - baseline.resourceUsage.mean) / baseline.resourceUsage.stdDev
    );

    if (resourceDeviation > this.anomalyThreshold) {
      anomalies.push({
        type: 'resource_usage',
        severity: resourceDeviation > 3 ? 'critical' : 'warning',
        value: metrics.resourceUsage.cpu,
        expected: baseline.resourceUsage.mean,
        deviation: resourceDeviation,
        message: `CPU usage ${metrics.resourceUsage.cpu}% is ${resourceDeviation.toFixed(1)} standard deviations from baseline`
      });
    }

    // Pattern-based anomalies
    const patternAnomalies = this.detectPatternAnomalies(tier, metrics);
    anomalies.push(...patternAnomalies);

    return anomalies;
  }

  /**
     * Detect pattern-based anomalies
     */
  detectPatternAnomalies (tier, metrics) {
    const anomalies = [];
    const recentMetrics = this.getRecentMetrics(tier, 20);

    if (recentMetrics.length < 10) return anomalies;

    // Sudden success rate drop
    const recentSuccessRate = recentMetrics.slice(-5)
      .reduce((sum, m) => sum + (m.success ? 1 : 0), 0) / 5;
    const historicalSuccessRate = recentMetrics.slice(0, -5)
      .reduce((sum, m) => sum + (m.success ? 1 : 0), 0) / (recentMetrics.length - 5);

    if (recentSuccessRate < historicalSuccessRate * 0.7) {
      anomalies.push({
        type: 'success_rate_drop',
        severity: 'critical',
        value: recentSuccessRate,
        expected: historicalSuccessRate,
        message: `Success rate dropped from ${(historicalSuccessRate * 100).toFixed(1)}% to ${(recentSuccessRate * 100).toFixed(1)}%`
      });
    }

    // Execution time trend anomaly
    const recentExecutionTimes = recentMetrics.slice(-5).map(m => m.executionTime);
    const executionTrend = this.calculateTrend(recentExecutionTimes);

    if (executionTrend.slope > 0 && executionTrend.confidence > 0.8) {
      anomalies.push({
        type: 'execution_time_trend',
        severity: 'warning',
        trend: executionTrend,
        message: `Execution time showing upward trend with ${(executionTrend.confidence * 100).toFixed(1)}% confidence`
      });
    }

    return anomalies;
  }

  /**
     * Handle detected anomalies
     */
  handleAnomalies (tier, anomalies, metrics) {
    for (const anomaly of anomalies) {
      const alert = {
        id: this.generateAlertId(),
        timestamp: Date.now(),
        tier,
        anomaly,
        metrics,
        status: 'active',
        severity: anomaly.severity
      };

      this.alerts.push(alert);

      if (this.alertingEnabled) {
        this.sendAlert(alert);
      }

      // Auto-remediation for certain anomaly types
      this.attemptAutoRemediation(tier, anomaly, metrics);
    }
  }

  /**
     * Attempt automatic remediation
     */
  attemptAutoRemediation (tier, anomaly, metrics) {
    const remediations = {
      execution_time: () => {
        if (anomaly.severity === 'critical' && tier === 'ultimate') {
          // Trigger immediate fallback to rapid tier
          return { action: 'trigger_fallback', target: 'rapid' };
        }
        return { action: 'monitor', duration: '15m' };
      },

      resource_usage: () => {
        if (anomaly.value > this.baselines[tier].resourceUsage.target) {
          return { action: 'reduce_frequency', factor: 0.5 };
        }
        return { action: 'monitor', duration: '5m' };
      },

      success_rate_drop: () => {
        return { action: 'enable_debug_mode', duration: '1h' };
      }
    };

    const remediation = remediations[anomaly.type];
    if (remediation) {
      const action = remediation();
      console.log(`Auto-remediation for ${tier}/${anomaly.type}:`, action);
      return action;
    }

    return null;
  }

  /**
     * Generate performance recommendations
     */
  generateRecommendations (tier, analysis, anomalies) {
    const recommendations = [];

    // Performance recommendations
    if (analysis.performance.executionTimeRatio > 1.2) {
      recommendations.push({
        type: 'performance',
        priority: 'high',
        message: `${tier} tier execution time 20% above target - consider optimization`,
        action: 'optimize_execution'
      });
    }

    // Efficiency recommendations
    if (analysis.efficiency.resourceScore < 70) {
      recommendations.push({
        type: 'efficiency',
        priority: 'medium',
        message: 'Resource efficiency below optimal - review resource allocation',
        action: 'optimize_resources'
      });
    }

    // Quality recommendations
    if (analysis.quality.qualityScore < 60) {
      recommendations.push({
        type: 'quality',
        priority: 'medium',
        message: 'Quality metrics below target - enhance implementation',
        action: 'improve_quality'
      });
    }

    // Anomaly-based recommendations
    for (const anomaly of anomalies) {
      if (anomaly.severity === 'critical') {
        recommendations.push({
          type: 'anomaly',
          priority: 'critical',
          message: `Critical anomaly detected: ${anomaly.message}`,
          action: 'investigate_anomaly'
        });
      }
    }

    // Trend-based recommendations
    if (analysis.trend.overall === 'degrading') {
      recommendations.push({
        type: 'trend',
        priority: 'high',
        message: 'Performance trend shows degradation - review recent changes',
        action: 'review_changes'
      });
    }

    return recommendations;
  }

  /**
     * Get tier comparison analytics
     * @param {Object} options - Comparison options
     * @returns {Object} Comprehensive tier comparison
     */
  getTierComparison (options = {}) {
    const timeWindow = options.timeWindow || '24h';
    const tiers = ['ultimate', 'rapid', 'smart'];

    const comparison = {
      timeWindow,
      tiers: {},
      rankings: {},
      insights: [],
      generatedAt: new Date().toISOString()
    };

    // Analyze each tier
    for (const tier of tiers) {
      const metrics = this.getMetricsForTimeWindow(tier, timeWindow);
      comparison.tiers[tier] = this.analyzeTierPerformance(tier, metrics);
    }

    // Generate rankings
    comparison.rankings = this.generateTierRankings(comparison.tiers);

    // Generate insights
    comparison.insights = this.generateComparisonInsights(comparison);

    return comparison;
  }

  /**
     * Analyze tier performance for comparison
     */
  analyzeTierPerformance (tier, metrics) {
    if (metrics.length === 0) {
      return {
        executionCount: 0,
        averageExecutionTime: 0,
        successRate: 0,
        resourceEfficiency: 0,
        qualityScore: 0,
        availability: 0
      };
    }

    const successfulExecutions = metrics.filter(m => m.success);
    const totalExecutionTime = metrics.reduce((sum, m) => sum + m.executionTime, 0);
    const totalResourceUsage = metrics.reduce((sum, m) => sum + m.resourceUsage.cpu, 0);
    const totalQualityScore = metrics.reduce((sum, m) => sum + this.calculateQualityScore(m.qualityMetrics), 0);

    return {
      executionCount: metrics.length,
      averageExecutionTime: totalExecutionTime / metrics.length,
      successRate: successfulExecutions.length / metrics.length,
      resourceEfficiency: 100 - (totalResourceUsage / metrics.length),
      qualityScore: totalQualityScore / metrics.length,
      availability: this.calculateAvailability(tier, metrics),
      throughput: this.calculateThroughput(metrics),
      errorRate: (metrics.length - successfulExecutions.length) / metrics.length
    };
  }

  /**
   * Get tier performance summary (alias for analyzeTierPerformance)
   * @param {string} tier - Automation tier
   * @returns {Object} Performance summary
   */
  async getTierPerformanceSummary (tier) {
    const metrics = this.getMetricsForTimeWindow(tier, '24h');
    const summary = this.analyzeTierPerformance(tier, metrics);
    
    // Add tier-specific information
    return {
      tier,
      ...summary,
      successRate: summary.successRate * 100, // Convert to percentage
      lastExecution: metrics.length > 0 ? metrics[0].timestamp : null,
      resourceUsage: {
        avgCpu: metrics.length > 0 ? metrics.reduce((sum, m) => sum + (m.resourceUsage?.cpu || 0), 0) / metrics.length : 0,
        avgMemory: metrics.length > 0 ? metrics.reduce((sum, m) => sum + (m.resourceUsage?.memory || 0), 0) / metrics.length : 0,
        avgApiCalls: metrics.length > 0 ? metrics.reduce((sum, m) => sum + (m.apiCalls || 0), 0) / metrics.length : 0
      }
    };
  }

  /**
   * Record metrics for a tier execution (alias for recordExecution)
   * @param {string} tier - Automation tier
   * @param {Object} metrics - Execution metrics
   * @returns {Object} Recording result with analysis
   */
  async recordMetrics (tier, metrics) {
    return this.recordExecution(tier, metrics);
  }

  /**
   * Generate comprehensive system report
   * @returns {Object} System performance report
   */
  async generateSystemReport () {
    const tiers = ['ultimate', 'rapid', 'smart'];
    const report = {
      timestamp: new Date().toISOString(),
      tiers: {},
      overall: {
        totalExecutions: 0,
        avgSuccessRate: 0,
        avgExecutionTime: 0
      }
    };

    for (const tier of tiers) {
      report.tiers[tier] = await this.getTierPerformanceSummary(tier);
      report.overall.totalExecutions += report.tiers[tier].executionCount;
    }

    // Calculate overall averages
    const tierSummaries = Object.values(report.tiers);
    if (tierSummaries.length > 0) {
      report.overall.avgSuccessRate = tierSummaries.reduce((sum, t) => sum + t.successRate, 0) / tierSummaries.length;
      report.overall.avgExecutionTime = tierSummaries.reduce((sum, t) => sum + t.averageExecutionTime, 0) / tierSummaries.length;
    }

    return report;
  }

  /**
     * Generate tier rankings
     */
  generateTierRankings (tierData) {
    const metrics = ['successRate', 'resourceEfficiency', 'qualityScore', 'availability'];
    const rankings = {};

    for (const metric of metrics) {
      const sorted = Object.entries(tierData)
        .filter(([tier, data]) => data.executionCount > 0)
        .sort(([, a], [, b]) => b[metric] - a[metric])
        .map(([tier]) => tier);

      rankings[metric] = sorted;
    }

    return rankings;
  }

  /**
     * Generate comparison insights
     */
  generateComparisonInsights (comparison) {
    const insights = [];
    const { tiers, rankings } = comparison;

    // Best performing tier overall
    const overallRanking = this.calculateOverallRanking(tiers);
    insights.push({
      type: 'best_performer',
      message: `${overallRanking[0]} tier is the best overall performer`,
      data: overallRanking
    });

    // Efficiency insights
    const efficiencyLeader = rankings.resourceEfficiency[0];
    insights.push({
      type: 'efficiency',
      message: `${efficiencyLeader} tier leads in resource efficiency`,
      value: tiers[efficiencyLeader].resourceEfficiency
    });

    // Quality insights
    const qualityLeader = rankings.qualityScore[0];
    insights.push({
      type: 'quality',
      message: `${qualityLeader} tier delivers highest quality results`,
      value: tiers[qualityLeader].qualityScore
    });

    // Availability insights
    const availabilityLeader = rankings.availability[0];
    insights.push({
      type: 'availability',
      message: `${availabilityLeader} tier has best availability`,
      value: tiers[availabilityLeader].availability
    });

    return insights;
  }

  /**
     * Get anomaly detection report
     * @param {Object} options - Report options
     * @returns {Object} Anomaly detection report
     */
  getAnomalyReport (options = {}) {
    const timeWindow = options.timeWindow || '24h';
    const severity = options.severity || 'all';

    const filteredAlerts = this.alerts.filter(alert => {
      const alertAge = Date.now() - alert.timestamp;
      const windowMs = this.parseTimeWindow(timeWindow);

      return alertAge <= windowMs &&
                   (severity === 'all' || alert.severity === severity);
    });

    const report = {
      timeWindow,
      totalAnomalies: filteredAlerts.length,
      severityBreakdown: this.getAnomalySeverityBreakdown(filteredAlerts),
      tierBreakdown: this.getAnomalyTierBreakdown(filteredAlerts),
      typeBreakdown: this.getAnomalyTypeBreakdown(filteredAlerts),
      trends: this.getAnomalyTrends(filteredAlerts),
      recommendations: this.getAnomalyRecommendations(filteredAlerts),
      generatedAt: new Date().toISOString()
    };

    return report;
  }

  /**
     * Helper methods for calculations
     */
  getPerformanceStatus (ratio, thresholds) {
    if (ratio <= thresholds[0]) return 'excellent';
    if (ratio <= thresholds[1]) return 'good';
    if (ratio <= thresholds[2]) return 'acceptable';
    return 'poor';
  }

  calculateResourceScore (resourceUsage) {
    const weights = { cpu: 0.4, memory: 0.3, apiCalls: 0.2, networkLatency: 0.1 };

    // Normalize scores (lower is better)
    const cpuScore = Math.max(0, 100 - resourceUsage.cpu);
    const memoryScore = Math.max(0, 100 - resourceUsage.memory);
    const apiScore = Math.max(0, 100 - (resourceUsage.apiCalls * 2));
    const latencyScore = Math.max(0, 100 - (resourceUsage.networkLatency / 10));

    return cpuScore * weights.cpu +
               memoryScore * weights.memory +
               apiScore * weights.apiCalls +
               latencyScore * weights.networkLatency;
  }

  calculateEfficiency (actual, baseline) {
    if (baseline === 0) return 1.0;
    return Math.max(0, Math.min(1, 1 - (actual - baseline) / baseline));
  }

  calculateCodeImpact (quality) {
    return (quality.linesChanged * 0.1 + quality.filesModified * 5) / 10;
  }

  calculateComprehensiveness (quality) {
    const factors = [
      quality.issuesProcessed > 0 ? 0.4 : 0,
      quality.linesChanged > 0 ? 0.3 : 0,
      quality.filesModified > 0 ? 0.2 : 0,
      quality.testsAdded > 0 ? 0.1 : 0
    ];
    return factors.reduce((sum, f) => sum + f, 0);
  }

  calculateQualityScore (quality) {
    const productivity = quality.issuesProcessed > 0 ? 25 : 0;
    const codeImpact = Math.min(25, this.calculateCodeImpact(quality));
    const testCoverage = quality.testsAdded > 0 ? 25 : 10;
    const comprehensiveness = this.calculateComprehensiveness(quality) * 25;

    return productivity + codeImpact + testCoverage + comprehensiveness;
  }

  calculateTrend (values) {
    if (values.length < 2) return { slope: 0, confidence: 0 };

    const n = values.length;
    const x = Array.from({ length: n }, (_, i) => i);
    const meanX = x.reduce((sum, val) => sum + val, 0) / n;
    const meanY = values.reduce((sum, val) => sum + val, 0) / n;

    const numerator = x.reduce((sum, xi, i) => sum + (xi - meanX) * (values[i] - meanY), 0);
    const denominator = x.reduce((sum, xi) => sum + (xi - meanX) ** 2, 0);

    const slope = denominator === 0 ? 0 : numerator / denominator;

    // Calculate R-squared for confidence
    const predictions = x.map(xi => meanY + slope * (xi - meanX));
    const totalSumSquares = values.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);
    const residualSumSquares = values.reduce((sum, yi, i) => sum + (yi - predictions[i]) ** 2, 0);
    const rSquared = totalSumSquares === 0 ? 0 : 1 - (residualSumSquares / totalSumSquares);

    return { slope, confidence: Math.max(0, rSquared) };
  }

  // Additional helper methods...
  cleanupOldMetrics (tierMetrics) {
    const cutoffTime = Date.now() - (this.retentionDays * 24 * 60 * 60 * 1000);
    tierMetrics.raw = tierMetrics.raw.filter(m => m.timestamp > cutoffTime);
  }

  updateAggregatedMetrics (tier, metrics) {
    // Implementation for aggregated metrics updates
    // This would aggregate metrics by different time intervals
  }

  estimateThroughput (metrics) {
    // Estimate executions per hour based on execution time
    const executionsPerHour = 3600000 / metrics.executionTime;
    return Math.round(executionsPerHour);
  }

  estimateCost (metrics) {
    // Simplified cost estimation based on resource usage
    const baseCost = 0.001; // Base cost per execution
    const resourceMultiplier = 1 + (metrics.resourceUsage.cpu / 100);
    return baseCost * resourceMultiplier;
  }

  getRecentMetrics (tier, count) {
    const tierMetrics = this.metrics.get(tier);
    if (!tierMetrics) return [];

    return tierMetrics.raw
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, count);
  }

  determineTrendDirection (trends) {
    const slopes = [trends.executionTime.slope, trends.resourceUsage.slope];
    const avgSlope = slopes.reduce((sum, s) => sum + s, 0) / slopes.length;

    if (avgSlope > 0.1) return 'degrading';
    if (avgSlope < -0.1) return 'improving';
    return 'stable';
  }

  calculateTrendConfidence (trends) {
    const confidences = [trends.executionTime.confidence, trends.resourceUsage.confidence];
    return confidences.reduce((sum, c) => sum + c, 0) / confidences.length;
  }

  generateAlertId () {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  sendAlert (alert) {
    // Implementation for sending alerts (email, webhook, etc.)
    console.log(`ALERT [${alert.severity.toUpperCase()}] ${alert.tier}: ${alert.anomaly.message}`);
  }

  getMetricsForTimeWindow (tier, timeWindow) {
    const tierMetrics = this.metrics.get(tier);
    if (!tierMetrics) return [];

    const windowMs = this.parseTimeWindow(timeWindow);
    const cutoffTime = Date.now() - windowMs;

    return tierMetrics.raw.filter(m => m.timestamp > cutoffTime);
  }

  parseTimeWindow (timeWindow) {
    const match = timeWindow.match(/^(\d+)([hmsd])$/);
    if (!match) return 24 * 60 * 60 * 1000; // Default 24 hours

    const value = parseInt(match[1]);
    const unit = match[2];

    const multipliers = {
      m: 60 * 1000,
      h: 60 * 60 * 1000,
      d: 24 * 60 * 60 * 1000,
      s: 1000
    };

    return value * (multipliers[unit] || multipliers.h);
  }

  calculateAvailability (tier, metrics) {
    // Calculate availability based on execution success and timing
    const targetExecutionsPerHour = {
      ultimate: 60, // Every minute
      rapid: 12, // Every 5 minutes
      smart: 0.33 // Every 3 hours
    };

    const target = targetExecutionsPerHour[tier] || 1;
    const actual = metrics.length;
    const expectedExecutions = target * 24; // For 24 hour period

    return Math.min(100, (actual / expectedExecutions) * 100);
  }

  calculateThroughput (metrics) {
    if (metrics.length === 0) return 0;

    const timeSpan = Math.max(1, (metrics[0].timestamp - metrics[metrics.length - 1].timestamp) / 1000 / 3600);
    return metrics.length / timeSpan; // Executions per hour
  }

  calculateOverallRanking (tiers) {
    const weights = {
      successRate: 0.3,
      resourceEfficiency: 0.25,
      qualityScore: 0.25,
      availability: 0.2
    };

    const scores = {};

    for (const [tier, data] of Object.entries(tiers)) {
      if (data.executionCount === 0) continue;

      scores[tier] =
                data.successRate * weights.successRate +
                (data.resourceEfficiency / 100) * weights.resourceEfficiency +
                (data.qualityScore / 100) * weights.qualityScore +
                (data.availability / 100) * weights.availability;
    }

    return Object.entries(scores)
      .sort(([, a], [, b]) => b - a)
      .map(([tier]) => tier);
  }

  getAnomalySeverityBreakdown (alerts) {
    const breakdown = { critical: 0, warning: 0, info: 0 };
    alerts.forEach(alert => {
      breakdown[alert.severity] = (breakdown[alert.severity] || 0) + 1;
    });
    return breakdown;
  }

  getAnomalyTierBreakdown (alerts) {
    const breakdown = {};
    alerts.forEach(alert => {
      breakdown[alert.tier] = (breakdown[alert.tier] || 0) + 1;
    });
    return breakdown;
  }

  getAnomalyTypeBreakdown (alerts) {
    const breakdown = {};
    alerts.forEach(alert => {
      const type = alert.anomaly.type;
      breakdown[type] = (breakdown[type] || 0) + 1;
    });
    return breakdown;
  }

  getAnomalyTrends (alerts) {
    // Analyze anomaly trends over time
    const hourlyBreakdown = {};
    alerts.forEach(alert => {
      const hour = new Date(alert.timestamp).getHours();
      hourlyBreakdown[hour] = (hourlyBreakdown[hour] || 0) + 1;
    });

    return {
      hourlyDistribution: hourlyBreakdown,
      peakHour: Object.entries(hourlyBreakdown).sort(([, a], [, b]) => b - a)[0]?.[0] || 'none'
    };
  }

  getAnomalyRecommendations (alerts) {
    const recommendations = [];

    const criticalCount = alerts.filter(a => a.severity === 'critical').length;
    if (criticalCount > 0) {
      recommendations.push({
        priority: 'high',
        message: `${criticalCount} critical anomalies detected - immediate investigation required`
      });
    }

    const tierFrequency = this.getAnomalyTierBreakdown(alerts);
    const problemTier = Object.entries(tierFrequency).sort(([, a], [, b]) => b - a)[0];
    if (problemTier && problemTier[1] > 3) {
      recommendations.push({
        priority: 'medium',
        message: `${problemTier[0]} tier showing frequent anomalies - review configuration`
      });
    }

    return recommendations;
  }
}

module.exports = PerformanceAnalyticsManager;
