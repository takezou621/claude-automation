/**
 * Branch Pattern Manager
 * 
 * Manages 9+ branch naming patterns with intelligent selection based on
 * issue type, priority, and repository context.
 * 
 * Generated by Claude Smart Automation
 */

class BranchPatternManager {
    constructor() {
        this.patterns = this.initializeBranchPatterns();
        this.validators = this.initializeValidators();
        this.sanitizers = this.initializeSanitizers();
    }

    /**
     * Initialize the 9+ branch naming patterns
     */
    initializeBranchPatterns() {
        return {
            // Critical/Emergency fixes
            'critical-fix': {
                template: 'critical/issue-{number}-{type}',
                description: 'Critical issues requiring immediate attention',
                priority: 100,
                maxLength: 50,
                allowedTypes: ['hotfix', 'security', 'data-loss', 'downtime']
            },

            // Security-related changes
            'security-fix': {
                template: 'security/issue-{number}-{sanitized-title}',
                description: 'Security vulnerabilities and patches',
                priority: 95,
                maxLength: 60,
                allowedTypes: ['vulnerability', 'patch', 'audit', 'compliance']
            },

            // Bug fixes
            'bugfix': {
                template: 'fix/issue-{number}-{sanitized-title}',
                description: 'Standard bug fixes and corrections',
                priority: 80,
                maxLength: 50,
                allowedTypes: ['bug', 'error', 'defect', 'regression']
            },

            // Feature development
            'feature': {
                template: 'feature/issue-{number}-{sanitized-title}',
                description: 'New feature implementation',
                priority: 70,
                maxLength: 55,
                allowedTypes: ['enhancement', 'new-feature', 'improvement']
            },

            // Documentation updates
            'documentation': {
                template: 'docs/issue-{number}-{sanitized-title}',
                description: 'Documentation updates and improvements',
                priority: 40,
                maxLength: 45,
                allowedTypes: ['documentation', 'readme', 'wiki', 'comments']
            },

            // Performance optimizations
            'performance': {
                template: 'perf/issue-{number}-{sanitized-title}',
                description: 'Performance improvements and optimizations',
                priority: 75,
                maxLength: 50,
                allowedTypes: ['optimization', 'performance', 'speed', 'memory']
            },

            // Code refactoring
            'refactor': {
                template: 'refactor/issue-{number}-{sanitized-title}',
                description: 'Code refactoring and cleanup',
                priority: 60,
                maxLength: 50,
                allowedTypes: ['cleanup', 'refactor', 'restructure', 'modernize']
            },

            // Testing improvements
            'testing': {
                template: 'test/issue-{number}-{sanitized-title}',
                description: 'Test coverage and quality improvements',
                priority: 50,
                maxLength: 45,
                allowedTypes: ['test', 'coverage', 'quality', 'validation']
            },

            // CI/CD pipeline changes
            'cicd': {
                template: 'ci/issue-{number}-{sanitized-title}',
                description: 'CI/CD pipeline modifications',
                priority: 65,
                maxLength: 45,
                allowedTypes: ['pipeline', 'workflow', 'deployment', 'build']
            },

            // Dependency updates
            'dependency': {
                template: 'deps/issue-{number}-{sanitized-title}',
                description: 'Dependency updates and management',
                priority: 45,
                maxLength: 50,
                allowedTypes: ['dependency', 'update', 'upgrade', 'security-update']
            },

            // Configuration changes
            'config': {
                template: 'config/issue-{number}-{sanitized-title}',
                description: 'Configuration and settings updates',
                priority: 55,
                maxLength: 50,
                allowedTypes: ['configuration', 'settings', 'env', 'params']
            },

            // Default fallback pattern
            'general': {
                template: 'general/issue-{number}-{sanitized-title}',
                description: 'General purpose branch for unclassified issues',
                priority: 30,
                maxLength: 50,
                allowedTypes: ['misc', 'other', 'general']
            }
        };
    }

    /**
     * Initialize validation functions
     */
    initializeValidators() {
        return {
            branchName: (name) => {
                // Git branch name validation rules
                const rules = [
                    // No spaces, must use hyphens or underscores
                    /^[a-zA-Z0-9/_-]+$/,
                    // Cannot start or end with slash
                    /^[^/].*[^/]$|^[^/]$/,
                    // Cannot have double slashes
                    /^(?!.*\/\/).*$/,
                    // Cannot start with dot
                    /^[^.].*$/,
                    // Maximum length check (will be done separately)
                    () => name.length <= 250
                ];

                return rules.every(rule => {
                    if (typeof rule === 'function') return rule();
                    return rule.test(name);
                });
            },

            patternType: (type) => {
                return Object.keys(this.patterns).includes(type);
            },

            issueNumber: (number) => {
                return Number.isInteger(number) && number > 0;
            }
        };
    }

    /**
     * Initialize sanitization functions
     */
    initializeSanitizers() {
        return {
            title: (title) => {
                return title
                    .toLowerCase()
                    .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove special chars except spaces and hyphens
                    .replace(/\s+/g, '-') // Replace spaces with hyphens
                    .replace(/-+/g, '-') // Replace multiple hyphens with single
                    .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
                    .substring(0, 30); // Limit length
            },

            branchName: (name) => {
                return name
                    .replace(/[^a-zA-Z0-9/_-]/g, '-') // Replace invalid chars with hyphens
                    .replace(/-+/g, '-') // Replace multiple hyphens with single
                    .replace(/\/+/g, '/') // Replace multiple slashes with single
                    .replace(/^\/|\/$/g, '') // Remove leading/trailing slashes
                    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
            }
        };
    }

    /**
     * Select optimal branch pattern based on issue analysis
     * @param {Object} issue - Issue object with title, labels, body, etc.
     * @param {Object} options - Additional options for pattern selection
     * @returns {Object} Selected pattern with metadata
     */
    selectPattern(issue, options = {}) {
        const analysis = this.analyzeIssue(issue);
        const candidates = this.getCandidatePatterns(analysis);
        const selected = this.rankAndSelectPattern(candidates, analysis, options);

        return {
            pattern: selected,
            analysis: analysis,
            confidence: selected.confidence,
            alternatives: candidates.slice(1, 4) // Top 3 alternatives
        };
    }

    /**
     * Analyze issue to determine characteristics
     * @param {Object} issue - Issue object
     * @returns {Object} Analysis results
     */
    analyzeIssue(issue) {
        const title = (issue.title || '').toLowerCase();
        const body = (issue.body || '').toLowerCase();
        const labels = (issue.labels || []).map(label => 
            typeof label === 'string' ? label.toLowerCase() : label.name.toLowerCase()
        );

        const analysis = {
            title: title,
            body: body,
            labels: labels,
            priority: this.detectPriority(labels, title, body),
            type: this.detectType(labels, title, body),
            complexity: this.detectComplexity(labels, title, body),
            risk: this.detectRisk(labels, title, body),
            urgency: this.detectUrgency(labels, title, body)
        };

        return analysis;
    }

    /**
     * Detect issue priority from labels and content
     */
    detectPriority(labels, title, body) {
        const priorityMap = {
            'critical': 100,
            'urgent': 90,
            'high': 80,
            'medium': 60,
            'low': 40,
            'trivial': 20
        };

        for (const [keyword, score] of Object.entries(priorityMap)) {
            if (labels.includes(keyword) || title.includes(keyword)) {
                return { level: keyword, score: score };
            }
        }

        return { level: 'medium', score: 60 };
    }

    /**
     * Detect issue type from labels and content
     */
    detectType(labels, title, body) {
        const typePatterns = {
            'security': ['security', 'vulnerability', 'cve', 'exploit', 'auth'],
            'bug': ['bug', 'error', 'fix', 'broken', 'issue', 'problem'],
            'feature': ['feature', 'enhancement', 'add', 'implement', 'new'],
            'performance': ['performance', 'slow', 'speed', 'optimize', 'perf'],
            'documentation': ['doc', 'readme', 'wiki', 'comment', 'document'],
            'test': ['test', 'coverage', 'spec', 'unit', 'integration'],
            'refactor': ['refactor', 'cleanup', 'restructure', 'modernize'],
            'dependency': ['dependency', 'update', 'upgrade', 'package'],
            'config': ['config', 'configuration', 'setting', 'env'],
            'cicd': ['ci', 'cd', 'pipeline', 'workflow', 'deploy', 'build']
        };

        for (const [type, patterns] of Object.entries(typePatterns)) {
            const matches = patterns.filter(pattern => 
                labels.includes(pattern) || 
                title.includes(pattern) || 
                body.includes(pattern)
            );

            if (matches.length > 0) {
                return { type: type, confidence: matches.length / patterns.length };
            }
        }

        return { type: 'general', confidence: 0.1 };
    }

    /**
     * Detect issue complexity
     */
    detectComplexity(labels, title, body) {
        const complexityIndicators = {
            high: ['refactor', 'architecture', 'breaking', 'major', 'complex'],
            medium: ['feature', 'enhancement', 'update', 'improve'],
            low: ['typo', 'comment', 'doc', 'simple', 'minor']
        };

        for (const [level, indicators] of Object.entries(complexityIndicators)) {
            if (indicators.some(indicator => 
                labels.includes(indicator) || 
                title.includes(indicator) || 
                body.includes(indicator)
            )) {
                return level;
            }
        }

        return 'medium';
    }

    /**
     * Detect risk level
     */
    detectRisk(labels, title, body) {
        const riskIndicators = {
            high: ['security', 'critical', 'data', 'auth', 'payment', 'breaking'],
            medium: ['api', 'database', 'user', 'feature'],
            low: ['doc', 'test', 'comment', 'style', 'typo']
        };

        for (const [level, indicators] of Object.entries(riskIndicators)) {
            if (indicators.some(indicator => 
                labels.includes(indicator) || 
                title.includes(indicator) || 
                body.includes(indicator)
            )) {
                return level;
            }
        }

        return 'medium';
    }

    /**
     * Detect urgency level
     */
    detectUrgency(labels, title, body) {
        const urgencyKeywords = ['urgent', 'asap', 'immediately', 'hotfix', 'critical'];
        
        const hasUrgencyKeyword = urgencyKeywords.some(keyword =>
            labels.includes(keyword) || 
            title.includes(keyword) || 
            body.includes(keyword)
        );

        return hasUrgencyKeyword ? 'high' : 'normal';
    }

    /**
     * Get candidate patterns based on analysis
     */
    getCandidatePatterns(analysis) {
        const candidates = [];

        // Add patterns based on type detection
        const primaryType = analysis.type.type;
        if (this.patterns[primaryType]) {
            candidates.push({
                ...this.patterns[primaryType],
                name: primaryType,
                confidence: analysis.type.confidence,
                score: this.patterns[primaryType].priority * analysis.type.confidence
            });
        }

        // Add patterns based on priority and urgency
        if (analysis.priority.score >= 90 || analysis.urgency === 'high') {
            candidates.push({
                ...this.patterns['critical-fix'],
                name: 'critical-fix',
                confidence: 0.9,
                score: this.patterns['critical-fix'].priority * 0.9
            });
        }

        // Add security pattern if risk is high
        if (analysis.risk === 'high' && !candidates.find(c => c.name === 'security-fix')) {
            candidates.push({
                ...this.patterns['security-fix'],
                name: 'security-fix',
                confidence: 0.8,
                score: this.patterns['security-fix'].priority * 0.8
            });
        }

        // Add general pattern as fallback
        if (!candidates.find(c => c.name === 'general')) {
            candidates.push({
                ...this.patterns['general'],
                name: 'general',
                confidence: 0.3,
                score: this.patterns['general'].priority * 0.3
            });
        }

        return candidates.sort((a, b) => b.score - a.score);
    }

    /**
     * Rank and select the best pattern
     */
    rankAndSelectPattern(candidates, analysis, options) {
        if (candidates.length === 0) {
            return {
                ...this.patterns['general'],
                name: 'general',
                confidence: 0.1,
                score: 0
            };
        }

        // Apply additional scoring based on options
        if (options.preferSecurity && candidates.find(c => c.name === 'security-fix')) {
            const securityCandidate = candidates.find(c => c.name === 'security-fix');
            securityCandidate.score *= 1.5;
        }

        if (options.preferStability && candidates.find(c => c.name === 'bugfix')) {
            const bugfixCandidate = candidates.find(c => c.name === 'bugfix');
            bugfixCandidate.score *= 1.3;
        }

        // Re-sort after scoring adjustments
        candidates.sort((a, b) => b.score - a.score);

        return candidates[0];
    }

    /**
     * Generate branch name from pattern and issue
     * @param {Object} pattern - Selected pattern
     * @param {Object} issue - Issue object
     * @param {Object} options - Generation options
     * @returns {Object} Generated branch info
     */
    generateBranchName(pattern, issue, options = {}) {
        const issueNumber = issue.number;
        const sanitizedTitle = this.sanitizers.title(issue.title || 'untitled');
        
        // Determine type suffix
        const typeMapping = {
            'critical-fix': this.detectCriticalType(issue),
            'security-fix': 'patch',
            'bugfix': 'fix',
            'feature': 'impl',
            'performance': 'opt',
            'refactor': 'cleanup'
        };

        const type = typeMapping[pattern.name] || 'update';

        // Build branch name from template
        let branchName = pattern.template
            .replace('{number}', issueNumber)
            .replace('{sanitized-title}', sanitizedTitle)
            .replace('{type}', type);

        // Apply length constraints
        if (branchName.length > pattern.maxLength) {
            const prefix = branchName.split('/')[0];
            const suffix = branchName.split('/')[1];
            const availableLength = pattern.maxLength - prefix.length - 1; // -1 for slash
            
            branchName = `${prefix}/${suffix.substring(0, availableLength)}`;
        }

        // Final sanitization
        branchName = this.sanitizers.branchName(branchName);

        // Validation
        if (!this.validators.branchName(branchName)) {
            console.warn(`Generated branch name failed validation: ${branchName}`);
            branchName = `${pattern.name.split('-')[0]}/issue-${issueNumber}`;
        }

        return {
            name: branchName,
            pattern: pattern.name,
            template: pattern.template,
            sanitizedTitle: sanitizedTitle,
            type: type,
            valid: this.validators.branchName(branchName),
            metadata: {
                originalTitle: issue.title,
                issueNumber: issueNumber,
                patternPriority: pattern.priority,
                generatedAt: new Date().toISOString()
            }
        };
    }

    /**
     * Detect critical fix type
     */
    detectCriticalType(issue) {
        const title = (issue.title || '').toLowerCase();
        const labels = (issue.labels || []).map(l => 
            typeof l === 'string' ? l : l.name
        ).join(' ').toLowerCase();

        if (title.includes('security') || labels.includes('security')) return 'security';
        if (title.includes('data') || labels.includes('data-loss')) return 'data-loss';
        if (title.includes('down') || labels.includes('downtime')) return 'downtime';
        
        return 'hotfix';
    }

    /**
     * Validate branch name against git rules
     * @param {string} branchName - Branch name to validate
     * @returns {Object} Validation result
     */
    validateBranchName(branchName) {
        const result = {
            valid: true,
            errors: [],
            warnings: []
        };

        // Check basic git rules
        if (!this.validators.branchName(branchName)) {
            result.valid = false;
            result.errors.push('Branch name contains invalid characters');
        }

        // Check length
        if (branchName.length > 250) {
            result.valid = false;
            result.errors.push('Branch name exceeds maximum length (250)');
        }

        // Check for best practices
        if (branchName.length > 50) {
            result.warnings.push('Branch name is quite long, consider shortening');
        }

        if (!branchName.includes('/')) {
            result.warnings.push('Consider using a category prefix (e.g., feature/, fix/)');
        }

        return result;
    }

    /**
     * Detect existing branch pattern from branch name
     * @param {string} branchName - Existing branch name
     * @returns {Object} Detection result
     */
    detectExistingPattern(branchName) {
        for (const [patternName, pattern] of Object.entries(this.patterns)) {
            const templateRegex = this.templateToRegex(pattern.template);
            const match = branchName.match(templateRegex);
            
            if (match) {
                return {
                    pattern: patternName,
                    template: pattern.template,
                    matches: match,
                    confidence: 0.9,
                    extracted: {
                        number: match.groups?.number,
                        title: match.groups?.title,
                        type: match.groups?.type
                    }
                };
            }
        }

        return {
            pattern: 'unknown',
            confidence: 0.1,
            matches: null,
            extracted: {}
        };
    }

    /**
     * Convert template string to regex for pattern detection
     */
    templateToRegex(template) {
        const regexString = template
            .replace(/\{number\}/g, '(?<number>\\d+)')
            .replace(/\{sanitized-title\}/g, '(?<title>[a-z0-9-]+)')
            .replace(/\{type\}/g, '(?<type>[a-z0-9-]+)')
            .replace(/\//g, '\\/');
        
        return new RegExp(`^${regexString}$`);
    }

    /**
     * Get pattern statistics and recommendations
     * @param {Array} recentBranches - Array of recent branch names
     * @returns {Object} Statistics and recommendations
     */
    getPatternStats(recentBranches = []) {
        const stats = {
            patternUsage: {},
            recommendations: [],
            totalBranches: recentBranches.length
        };

        // Analyze pattern usage
        for (const branchName of recentBranches) {
            const detection = this.detectExistingPattern(branchName);
            const pattern = detection.pattern;
            
            stats.patternUsage[pattern] = (stats.patternUsage[pattern] || 0) + 1;
        }

        // Generate recommendations
        const mostUsed = Object.entries(stats.patternUsage)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 3);

        if (mostUsed.length > 0) {
            stats.recommendations.push(
                `Most used pattern: ${mostUsed[0][0]} (${mostUsed[0][1]} times)`
            );
        }

        const unknownCount = stats.patternUsage['unknown'] || 0;
        if (unknownCount > 0) {
            stats.recommendations.push(
                `${unknownCount} branches don't follow standard patterns - consider standardization`
            );
        }

        return stats;
    }
}

module.exports = BranchPatternManager;