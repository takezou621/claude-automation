/**
 * Tier Execution Handler
 *
 * Comprehensive error handling system with fallback mechanisms,
 * critical error detection, administrator notifications, and retry logic.
 *
 * Generated by Claude Smart Automation
 */

class TierExecutionHandler {
  constructor (configManager, options = {}) {
    this.configManager = configManager;

    // Get configuration from ConfigManager or use defaults
    const tierSelectionConfig = this.configManager
      ? this.configManager.getTierSelectionConfig()
      : {};

    this.maxRetries = options.maxRetries || 3;
    this.baseBackoffMs = options.baseBackoffMs || 1000;
    this.maxBackoffMs = options.maxBackoffMs || 30000;
    this.criticalErrorThreshold = options.criticalErrorThreshold || 3;
    this.adminNotificationEnabled = options.adminNotificationEnabled !== false;
    this.fallbackChain = options.fallbackChain || tierSelectionConfig.fallbackChain || ['ultimate', 'rapid', 'smart'];

    this.executionHistory = new Map();
    this.errorCounts = new Map();
    this.criticalErrors = [];
    this.adminNotifications = [];
  }

  /**
     * Execute a tier with comprehensive error handling
     * @param {string} tier - Automation tier (ultimate, rapid, smart)
     * @param {Object} context - Execution context
     * @param {Function} executionFunction - Function to execute
     * @returns {Object} Execution result with error handling metadata
     */
  async executeTierWithHandling (tier, context, executionFunction) {
    // Check if tier is enabled before execution
    if (!this.isTierEnabled(tier)) {
      console.warn(`‚ö†Ô∏è ${tier} tier is disabled, skipping execution`);
      return {
        success: false,
        error: new Error(`${tier} tier is disabled`),
        execution: {
          tier,
          status: 'disabled',
          error: `${tier} tier is disabled in configuration`
        }
      };
    }

    const executionId = this.generateExecutionId(tier);
    const startTime = Date.now();

    console.log(`üöÄ Starting ${tier} tier execution (${executionId})`);

    const execution = {
      id: executionId,
      tier,
      startTime,
      context,
      attempts: [],
      status: 'running',
      result: null,
      error: null,
      fallbackTriggered: false,
      adminNotified: false
    };

    this.executionHistory.set(executionId, execution);

    try {
      const result = await this.executeWithRetry(
        tier,
        context,
        executionFunction,
        execution
      );

      execution.status = 'completed';
      execution.result = result;
      execution.endTime = Date.now();
      execution.duration = execution.endTime - execution.startTime;

      console.log(`‚úÖ ${tier} tier execution completed successfully (${execution.duration}ms)`);

      // Reset error count on success
      this.resetErrorCount(tier);

      return {
        success: true,
        execution,
        result,
        recommendations: this.generateSuccessRecommendations(execution)
      };
    } catch (error) {
      execution.status = 'failed';
      execution.error = this.normalizeError(error);
      execution.endTime = Date.now();
      execution.duration = execution.endTime - execution.startTime;

      console.error(`‚ùå ${tier} tier execution failed: ${error.message}`);

      // Handle the error and determine next steps
      const errorHandling = await this.handleExecutionError(tier, execution, error);

      return {
        success: false,
        execution,
        error: execution.error,
        errorHandling,
        recommendations: this.generateFailureRecommendations(execution, errorHandling)
      };
    }
  }

  /**
     * Execute with retry logic and exponential backoff
     */
  async executeWithRetry (tier, context, executionFunction, execution) {
    let lastError = null;

    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      const attemptId = `${execution.id}_attempt_${attempt}`;
      const attemptStart = Date.now();

      console.log(`üîÑ ${tier} tier attempt ${attempt}/${this.maxRetries} (${attemptId})`);

      const attemptRecord = {
        id: attemptId,
        attempt,
        startTime: attemptStart,
        status: 'running'
      };

      execution.attempts.push(attemptRecord);

      try {
        const result = await this.executeWithTimeout(
          tier,
          context,
          executionFunction,
          this.getTierTimeout(tier)
        );

        attemptRecord.status = 'completed';
        attemptRecord.endTime = Date.now();
        attemptRecord.duration = attemptRecord.endTime - attemptRecord.startTime;
        attemptRecord.result = result;

        console.log(`‚úÖ ${tier} tier attempt ${attempt} succeeded (${attemptRecord.duration}ms)`);
        return result;
      } catch (error) {
        lastError = error;
        attemptRecord.status = 'failed';
        attemptRecord.endTime = Date.now();
        attemptRecord.duration = attemptRecord.endTime - attemptRecord.startTime;
        attemptRecord.error = this.normalizeError(error);

        console.error(`‚ùå ${tier} tier attempt ${attempt} failed: ${error.message}`);

        // Check if this is a critical error that should not be retried
        if (this.isCriticalError(error)) {
          console.error('üö® Critical error detected, stopping retries');
          await this.handleCriticalError(tier, error, execution);
          throw error;
        }

        // Wait before next attempt (except on last attempt)
        if (attempt < this.maxRetries) {
          const backoffMs = this.calculateBackoff(attempt);
          console.log(`‚è≥ Waiting ${backoffMs}ms before retry...`);
          await this.sleep(backoffMs);
        }
      }
    }

    // All retries exhausted
    await this.handleRetriesExhausted(tier, lastError, execution);
    throw lastError;
  }

  /**
     * Execute with timeout protection
     */
  async executeWithTimeout (tier, context, executionFunction, timeoutMs) {
    return new Promise(async (resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`${tier} tier execution timed out after ${timeoutMs}ms`));
      }, timeoutMs);

      try {
        const result = await executionFunction(context);
        clearTimeout(timeout);
        resolve(result);
      } catch (error) {
        clearTimeout(timeout);
        reject(error);
      }
    });
  }

  /**
     * Handle execution errors and determine fallback strategy
     */
  async handleExecutionError (tier, execution, error) {
    this.incrementErrorCount(tier);

    const errorAnalysis = this.analyzeError(error);
    const errorHandling = {
      analysis: errorAnalysis,
      fallbackTriggered: false,
      criticalErrorDetected: false,
      adminNotified: false,
      nextAction: 'none'
    };

    // Check for critical error patterns
    if (this.isCriticalError(error) || this.hasCriticalErrorCount(tier)) {
      errorHandling.criticalErrorDetected = true;
      await this.handleCriticalError(tier, error, execution);
      errorHandling.adminNotified = true;
    }

    // Determine if fallback should be triggered
    const fallbackDecision = this.decideFallback(tier, errorAnalysis, execution);

    if (fallbackDecision.shouldFallback) {
      errorHandling.fallbackTriggered = true;
      errorHandling.fallbackTier = fallbackDecision.targetTier;
      errorHandling.nextAction = 'fallback';

      await this.triggerFallback(
        tier,
        fallbackDecision.targetTier,
        execution.context,
        error
      );
    } else if (errorAnalysis.retryable && !this.hasCriticalErrorCount(tier)) {
      errorHandling.nextAction = 'wait_and_monitor';
    } else {
      errorHandling.nextAction = 'manual_intervention';
      if (this.adminNotificationEnabled) {
        await this.notifyAdministrator(tier, error, execution);
        errorHandling.adminNotified = true;
      }
    }

    return errorHandling;
  }

  /**
     * Analyze error to determine characteristics and handling strategy
     */
  analyzeError (error) {
    const errorMessage = error.message.toLowerCase();
    const errorStack = error.stack || '';

    const analysis = {
      type: 'unknown',
      severity: 'medium',
      retryable: true,
      requiresFallback: false,
      category: 'general'
    };

    // Categorize error types
    if (errorMessage.includes('timeout')) {
      analysis.type = 'timeout';
      analysis.category = 'performance';
      analysis.retryable = true;
      analysis.requiresFallback = true;
    } else if (errorMessage.includes('rate limit') || errorMessage.includes('api limit')) {
      analysis.type = 'rate_limit';
      analysis.category = 'api';
      analysis.retryable = true;
      analysis.requiresFallback = false;
    } else if (errorMessage.includes('authentication') || errorMessage.includes('unauthorized')) {
      analysis.type = 'authentication';
      analysis.category = 'security';
      analysis.severity = 'high';
      analysis.retryable = false;
      analysis.requiresFallback = false;
    } else if (errorMessage.includes('network') || errorMessage.includes('connection')) {
      analysis.type = 'network';
      analysis.category = 'connectivity';
      analysis.retryable = true;
      analysis.requiresFallback = true;
    } else if (errorMessage.includes('memory') || errorMessage.includes('out of memory')) {
      analysis.type = 'memory';
      analysis.category = 'resource';
      analysis.severity = 'high';
      analysis.retryable = false;
      analysis.requiresFallback = true;
    } else if (errorMessage.includes('syntax') || errorMessage.includes('parse')) {
      analysis.type = 'syntax';
      analysis.category = 'validation';
      analysis.retryable = false;
      analysis.requiresFallback = false;
    } else if (errorMessage.includes('permission') || errorMessage.includes('access denied')) {
      analysis.type = 'permission';
      analysis.category = 'security';
      analysis.severity = 'high';
      analysis.retryable = false;
      analysis.requiresFallback = false;
    } else if (errorStack.includes('github') && errorMessage.includes('api')) {
      analysis.type = 'github_api';
      analysis.category = 'api';
      analysis.retryable = true;
      analysis.requiresFallback = true;
    }

    // Determine severity
    const highSeverityKeywords = ['critical', 'fatal', 'security', 'authentication', 'permission'];
    const lowSeverityKeywords = ['warning', 'info', 'timeout', 'retry'];

    if (highSeverityKeywords.some(keyword => errorMessage.includes(keyword))) {
      analysis.severity = 'high';
    } else if (lowSeverityKeywords.some(keyword => errorMessage.includes(keyword))) {
      analysis.severity = 'low';
    }

    return analysis;
  }

  /**
     * Decide whether to trigger fallback
     */
  decideFallback (tier, errorAnalysis, execution) {
    const decision = {
      shouldFallback: false,
      targetTier: null,
      reason: ''
    };

    // Don't fallback if no fallback tier is configured
    const tierIndex = this.fallbackChain.indexOf(tier);
    if (tierIndex === -1 || tierIndex === this.fallbackChain.length - 1) {
      decision.reason = 'No fallback tier available';
      return decision;
    }

    const targetTier = this.fallbackChain[tierIndex + 1];

    // Fallback conditions
    if (errorAnalysis.requiresFallback) {
      decision.shouldFallback = true;
      decision.targetTier = targetTier;
      decision.reason = `Error type '${errorAnalysis.type}' requires fallback`;
    } else if (execution.attempts.length >= this.maxRetries && errorAnalysis.retryable) {
      decision.shouldFallback = true;
      decision.targetTier = targetTier;
      decision.reason = 'Max retries exhausted, attempting fallback';
    } else if (this.getErrorCount(tier) >= this.criticalErrorThreshold) {
      decision.shouldFallback = true;
      decision.targetTier = targetTier;
      decision.reason = 'Critical error threshold reached';
    }

    return decision;
  }

  /**
     * Trigger fallback to another tier
     */
  async triggerFallback (fromTier, toTier, context, originalError) {
    console.log(`üîÑ Triggering fallback from ${fromTier} to ${toTier} tier`);

    const fallbackContext = {
      ...context,
      fallbackFrom: fromTier,
      originalError: originalError.message,
      fallbackReason: 'execution_failure',
      fallbackTimestamp: new Date().toISOString()
    };

    try {
      // This would integrate with the workflow dispatch system
      // For now, we'll simulate the trigger
      const triggerResult = await this.dispatchWorkflow(toTier, fallbackContext);

      console.log(`‚úÖ Fallback to ${toTier} tier triggered successfully`);
      return triggerResult;
    } catch (fallbackError) {
      console.error(`‚ùå Failed to trigger fallback to ${toTier}: ${fallbackError.message}`);

      // If fallback fails, try the next tier in the chain
      const toTierIndex = this.fallbackChain.indexOf(toTier);
      if (toTierIndex < this.fallbackChain.length - 1) {
        const nextTier = this.fallbackChain[toTierIndex + 1];
        return await this.triggerFallback(fromTier, nextTier, context, originalError);
      }

      throw fallbackError;
    }
  }

  /**
     * Handle critical errors
     */
  async handleCriticalError (tier, error, execution) {
    const criticalError = {
      id: this.generateCriticalErrorId(),
      timestamp: new Date().toISOString(),
      tier,
      executionId: execution.id,
      error: this.normalizeError(error),
      context: execution.context,
      severity: 'critical',
      status: 'active'
    };

    this.criticalErrors.push(criticalError);

    console.error(`üö® Critical error recorded for ${tier} tier: ${criticalError.id}`);

    if (this.adminNotificationEnabled) {
      await this.notifyAdministrator(tier, error, execution, criticalError);
    }

    // Implement emergency actions
    await this.executeEmergencyActions(tier, criticalError);

    return criticalError;
  }

  /**
     * Execute emergency actions for critical errors
     */
  async executeEmergencyActions (tier, criticalError) {
    const actions = [];

    // Disable the failing tier temporarily
    if (this.getErrorCount(tier) >= this.criticalErrorThreshold) {
      actions.push(this.temporarilyDisableTier(tier));
    }

    // Create incident report
    actions.push(this.createIncidentReport(tier, criticalError));

    // Emergency notification
    actions.push(this.sendEmergencyNotification(tier, criticalError));

    try {
      await Promise.all(actions);
      console.log(`üö® Emergency actions executed for ${tier} tier`);
    } catch (error) {
      console.error(`‚ùå Failed to execute emergency actions: ${error.message}`);
    }
  }

  /**
     * Temporarily disable a tier
     */
  async temporarilyDisableTier (tier) {
    console.log(`üö´ Temporarily disabling ${tier} tier due to critical errors`);

    // This would integrate with the configuration system
    // For now, we'll track the disabled status
    const disabledUntil = new Date(Date.now() + 30 * 60 * 1000); // 30 minutes

    // Set a timer to re-enable the tier
    setTimeout(() => {
      console.log(`‚úÖ Re-enabling ${tier} tier after cooldown period`);
      this.resetErrorCount(tier);
    }, 30 * 60 * 1000);

    return {
      action: 'disable_tier',
      tier,
      disabledUntil: disabledUntil.toISOString(),
      reason: 'critical_error_threshold_reached'
    };
  }

  /**
     * Create incident report
     */
  async createIncidentReport (tier, criticalError) {
    const report = {
      id: `incident_${Date.now()}`,
      timestamp: new Date().toISOString(),
      tier,
      severity: 'critical',
      summary: `Critical error in ${tier} tier automation`,
      details: {
        errorId: criticalError.id,
        errorMessage: criticalError.error.message,
        executionId: criticalError.executionId,
        context: criticalError.context
      },
      status: 'open',
      assignee: 'automation-team'
    };

    console.log(`üìã Incident report created: ${report.id}`);
    return report;
  }

  /**
     * Send emergency notification
     */
  async sendEmergencyNotification (tier, criticalError) {
    const notification = {
      id: this.generateNotificationId(),
      timestamp: new Date().toISOString(),
      type: 'emergency',
      tier,
      subject: `üö® Critical Error in ${tier.toUpperCase()} Tier Automation`,
      message: `Critical error detected in ${tier} tier automation (${criticalError.id}). Immediate attention required.`,
      criticalErrorId: criticalError.id,
      urgency: 'immediate'
    };

    // This would integrate with actual notification systems
    console.log(`üö® Emergency notification sent: ${notification.subject}`);
    return notification;
  }

  /**
     * Notify administrator of errors
     */
  async notifyAdministrator (tier, error, execution, criticalError = null) {
    const notification = {
      id: this.generateNotificationId(),
      timestamp: new Date().toISOString(),
      type: criticalError ? 'critical_error' : 'execution_failure',
      tier,
      executionId: execution.id,
      error: this.normalizeError(error),
      criticalErrorId: criticalError?.id || null,
      context: execution.context,
      recommendations: this.generateAdminRecommendations(tier, error, execution)
    };

    this.adminNotifications.push(notification);

    const subject = criticalError
      ? `üö® Critical Error in ${tier.toUpperCase()} Tier`
      : `‚ö†Ô∏è ${tier.toUpperCase()} Tier Execution Failed`;

    console.log(`üìß Admin notification: ${subject} (${notification.id})`);

    // This would integrate with actual notification systems (email, Slack, etc.)
    return notification;
  }

  /**
     * Generate admin recommendations
     */
  generateAdminRecommendations (tier, error, execution) {
    const recommendations = [];
    const errorAnalysis = this.analyzeError(error);

    if (errorAnalysis.type === 'timeout') {
      recommendations.push('Consider increasing timeout limits for this tier');
      recommendations.push('Review system resource availability');
    } else if (errorAnalysis.type === 'rate_limit') {
      recommendations.push('Review API rate limiting configuration');
      recommendations.push('Consider implementing request throttling');
    } else if (errorAnalysis.type === 'authentication') {
      recommendations.push('Verify API credentials and permissions');
      recommendations.push('Check token expiration status');
    } else if (errorAnalysis.type === 'memory') {
      recommendations.push('Review memory allocation for tier');
      recommendations.push('Consider reducing concurrent executions');
    }

    if (this.getErrorCount(tier) >= this.criticalErrorThreshold) {
      recommendations.push(`Consider temporarily disabling ${tier} tier`);
      recommendations.push('Investigate systematic issues');
    }

    return recommendations;
  }

  /**
     * Dispatch workflow for fallback tier
     */
  async dispatchWorkflow (tier, context) {
    // This would integrate with GitHub Actions workflow dispatch
    // For now, simulate the dispatch
    console.log(`üöÄ Dispatching ${tier} tier workflow with fallback context`);

    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          dispatched: true,
          tier,
          workflowId: `claude-${tier}-automation.yml`,
          dispatchId: this.generateDispatchId()
        });
      }, 100);
    });
  }

  /**
     * Utility methods
     */
  generateExecutionId (tier) {
    return `${tier}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  generateCriticalErrorId () {
    return `critical_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  generateNotificationId () {
    return `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  generateDispatchId () {
    return `dispatch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  normalizeError (error) {
    return {
      message: error.message,
      name: error.name,
      stack: error.stack,
      code: error.code || null,
      timestamp: new Date().toISOString()
    };
  }

  isCriticalError (error) {
    const criticalPatterns = [
      'authentication failed',
      'access denied',
      'permission denied',
      'unauthorized',
      'rate limit exceeded',
      'out of memory',
      'fatal error',
      'critical system error'
    ];

    const errorMessage = error.message.toLowerCase();
    return criticalPatterns.some(pattern => errorMessage.includes(pattern));
  }

  incrementErrorCount (tier) {
    const currentCount = this.errorCounts.get(tier) || 0;
    this.errorCounts.set(tier, currentCount + 1);
  }

  getErrorCount (tier) {
    return this.errorCounts.get(tier) || 0;
  }

  resetErrorCount (tier) {
    this.errorCounts.set(tier, 0);
  }

  hasCriticalErrorCount (tier) {
    return this.getErrorCount(tier) >= this.criticalErrorThreshold;
  }

  getTierTimeout (tier) {
    // Default timeouts (fallback if ConfigManager not available)
    const defaultTimeouts = {
      ultimate: 45000, // 45 seconds
      rapid: 240000, // 4 minutes
      smart: 900000 // 15 minutes
    };

    if (!this.configManager) {
      return defaultTimeouts[tier] || 300000; // Default 5 minutes
    }

    // Get timeout from ConfigManager tier configuration
    const tierConfig = this.configManager.getTierConfig(tier);
    if (tierConfig && tierConfig.maxExecutionTime) {
      return tierConfig.maxExecutionTime;
    }

    return defaultTimeouts[tier] || 300000; // Default 5 minutes
  }

  /**
   * Check if tier is enabled and available for execution
   */
  isTierEnabled (tier) {
    if (!this.configManager) {
      return true; // Default to enabled if no ConfigManager
    }

    const tierConfig = this.configManager.getTierConfig(tier);
    return tierConfig ? tierConfig.enabled : false;
  }

  calculateBackoff (attempt) {
    const backoff = this.baseBackoffMs * Math.pow(2, attempt - 1);
    return Math.min(backoff, this.maxBackoffMs);
  }

  sleep (ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async handleRetriesExhausted (tier, error, execution) {
    console.error(`‚ùå All retries exhausted for ${tier} tier execution`);

    if (this.adminNotificationEnabled) {
      await this.notifyAdministrator(tier, error, execution);
    }
  }

  /**
     * Generate recommendations based on execution results
     */
  generateSuccessRecommendations (execution) {
    const recommendations = [];

    if (execution.duration > this.getTierTimeout(execution.tier) * 0.8) {
      recommendations.push({
        type: 'performance',
        priority: 'medium',
        message: 'Execution time approaching timeout limit',
        action: 'optimize_performance'
      });
    }

    if (execution.attempts.length > 1) {
      recommendations.push({
        type: 'reliability',
        priority: 'low',
        message: `Required ${execution.attempts.length} attempts to succeed`,
        action: 'investigate_intermittent_issues'
      });
    }

    return recommendations;
  }

  generateFailureRecommendations (execution, errorHandling) {
    const recommendations = [];

    if (errorHandling.criticalErrorDetected) {
      recommendations.push({
        type: 'critical',
        priority: 'high',
        message: 'Critical error detected - immediate investigation required',
        action: 'investigate_critical_error'
      });
    }

    if (errorHandling.fallbackTriggered) {
      recommendations.push({
        type: 'fallback',
        priority: 'medium',
        message: `Fallback to ${errorHandling.fallbackTier} tier triggered`,
        action: 'monitor_fallback_execution'
      });
    }

    if (errorHandling.nextAction === 'manual_intervention') {
      recommendations.push({
        type: 'manual',
        priority: 'high',
        message: 'Manual intervention required',
        action: 'schedule_manual_review'
      });
    }

    return recommendations;
  }

  /**
     * Get execution statistics
     */
  getExecutionStatistics (timeWindow = '24h') {
    const windowMs = this.parseTimeWindow(timeWindow);
    const cutoffTime = Date.now() - windowMs;

    const recentExecutions = Array.from(this.executionHistory.values())
      .filter(exec => exec.startTime > cutoffTime);

    const stats = {
      totalExecutions: recentExecutions.length,
      successfulExecutions: recentExecutions.filter(e => e.status === 'completed').length,
      failedExecutions: recentExecutions.filter(e => e.status === 'failed').length,
      fallbackTriggered: recentExecutions.filter(e => e.fallbackTriggered).length,
      criticalErrors: this.criticalErrors.filter(e =>
        new Date(e.timestamp).getTime() > cutoffTime
      ).length,
      averageExecutionTime: 0,
      tierBreakdown: {}
    };

    stats.successRate = stats.totalExecutions > 0
      ? (stats.successfulExecutions / stats.totalExecutions) * 100
      : 0;

    // Calculate average execution time
    const completedExecutions = recentExecutions.filter(e => e.duration);
    if (completedExecutions.length > 0) {
      stats.averageExecutionTime = completedExecutions
        .reduce((sum, e) => sum + e.duration, 0) / completedExecutions.length;
    }

    // Tier breakdown
    for (const tier of ['ultimate', 'rapid', 'smart']) {
      const tierExecutions = recentExecutions.filter(e => e.tier === tier);
      stats.tierBreakdown[tier] = {
        total: tierExecutions.length,
        successful: tierExecutions.filter(e => e.status === 'completed').length,
        failed: tierExecutions.filter(e => e.status === 'failed').length,
        successRate: tierExecutions.length > 0
          ? (tierExecutions.filter(e => e.status === 'completed').length / tierExecutions.length) * 100
          : 0
      };
    }

    return stats;
  }

  parseTimeWindow (timeWindow) {
    const match = timeWindow.match(/^(\d+)([hmsd])$/);
    if (!match) return 24 * 60 * 60 * 1000; // Default 24 hours

    const value = parseInt(match[1]);
    const unit = match[2];

    const multipliers = {
      s: 1000,
      m: 60 * 1000,
      h: 60 * 60 * 1000,
      d: 24 * 60 * 60 * 1000
    };

    return value * (multipliers[unit] || multipliers.h);
  }
}

module.exports = TierExecutionHandler;
