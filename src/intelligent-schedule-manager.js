/**
 * Intelligent Schedule Manager
 *
 * Implements RepairGPT-optimized scheduling with timezone awareness,
 * repository activity pattern analysis, and resource contention prevention.
 *
 * Generated by Claude Smart Automation
 */

const moment = require('moment-timezone');

class IntelligentScheduleManager {
  constructor (configManager, options = {}) {
    this.configManager = configManager;
    this.timezone = options.timezone || 'UTC';
    this.activityAnalysisWindow = options.activityAnalysisWindow || 30; // days
    this.resourceThresholds = this.initializeResourceThresholds();
    this.scheduleCache = new Map();
    this.activityCache = new Map();
    this.cacheTimeout = options.cacheTimeout || 5 * 60 * 1000; // 5 minutes
  }

  /**
     * Initialize resource threshold configurations from ConfigManager
     */
  initializeResourceThresholds () {
    // Get resource thresholds from ConfigManager or use defaults
    const defaults = {
      github: {
        apiCalls: {
          hourly: 4000, // Conservative limit for GitHub API
          concurrent: 10 // Max concurrent API calls
        },
        actions: {
          concurrent: 5, // Max concurrent workflow runs
          minutesWindow: 20 // Analysis window for concurrency
        }
      },
      system: {
        cpuThreshold: 80, // CPU usage percentage
        memoryThreshold: 85, // Memory usage percentage
        diskThreshold: 90 // Disk usage percentage
      }
    };

    if (!this.configManager) {
      return defaults;
    }

    // Try to get from ConfigManager, merge with defaults
    const configThresholds = this.configManager.get('automation.resourceThresholds', {});
    return {
      github: {
        ...defaults.github,
        ...configThresholds.github
      },
      system: {
        ...defaults.system,
        ...configThresholds.system
      }
    };
  }

  /**
     * Get optimal execution schedule based on RepairGPT research
     * @param {string} tier - Automation tier (ultimate, rapid, smart)
     * @param {Object} options - Scheduling options
     * @returns {Object} Optimal schedule configuration
     */
  getOptimalSchedule (tier, options = {}) {
    const baseSchedules = this.getBaseSchedules();
    const activityAnalysis = this.getRepositoryActivityAnalysis();
    const resourceAnalysis = this.getResourceAnalysis();

    let schedule = { ...baseSchedules[tier] };

    // Apply timezone optimization
    if (options.timezone) {
      schedule = this.applyTimezoneOptimization(schedule, options.timezone);
    }

    // Apply activity pattern optimization
    if (activityAnalysis.confidence > 0.7) {
      schedule = this.applyActivityOptimization(schedule, activityAnalysis);
    }

    // Apply resource contention prevention
    schedule = this.applyResourceOptimization(schedule, resourceAnalysis);

    return {
      ...schedule,
      metadata: {
        optimizedFor: tier,
        activityConfidence: activityAnalysis.confidence,
        resourceStatus: resourceAnalysis.status,
        generatedAt: new Date().toISOString(),
        nextRecommendedReview: this.getNextReviewTime()
      }
    };
  }

  /**
     * Get base schedules for each automation tier
     */
  getBaseSchedules () {
    // Default schedules (fallback if ConfigManager not available)
    const defaults = {
      ultimate: {
        type: 'ultimate',
        cron: '* * * * *', // Every minute
        maxExecutionTime: 45000, // 45 seconds
        priority: 100,
        description: 'Ultra-fast execution for critical issues',
        fallbackTier: 'rapid',
        cooldownMinutes: 0,
        resourceRequirement: 'minimal'
      },

      rapid: {
        type: 'rapid',
        cron: '*/5 * * * *', // Every 5 minutes
        maxExecutionTime: 240000, // 4 minutes
        priority: 80,
        description: 'Balanced speed vs quality processing',
        fallbackTier: 'smart',
        cooldownMinutes: 5,
        resourceRequirement: 'moderate'
      },

      smart: {
        type: 'smart',
        cron: {
          weekdays: ['0 14 * * 1-5', '0 17 * * 1-5', '0 20 * * 1-5'],
          weekends: ['0 1 * * 0,6', '0 5 * * 0,6', '0 9 * * 0,6', '0 13 * * 0,6']
        },
        maxExecutionTime: 900000, // 15 minutes
        priority: 60,
        description: 'Comprehensive quality-focused processing',
        fallbackTier: null,
        cooldownMinutes: 180, // 3 hours minimum between runs
        resourceRequirement: 'high'
      }
    };

    if (!this.configManager) {
      return defaults;
    }

    // Get tier configurations from ConfigManager
    const schedules = {};
    for (const tier of ['ultimate', 'rapid', 'smart']) {
      const tierConfig = this.configManager.getTierConfig(tier);
      if (tierConfig) {
        schedules[tier] = {
          type: tier,
          cron: tierConfig.schedule,
          maxExecutionTime: tierConfig.maxExecutionTime,
          priority: tierConfig.priority,
          description: defaults[tier].description,
          fallbackTier: tierConfig.fallbackTier,
          cooldownMinutes: tierConfig.cooldownMinutes,
          resourceRequirement: this.getResourceRequirement(tierConfig.resourceLimits),
          enabled: tierConfig.enabled
        };
      } else {
        schedules[tier] = defaults[tier];
      }
    }

    return schedules;
  }

  /**
   * Map resource limits to requirement level
   */
  getResourceRequirement (resourceLimits) {
    if (!resourceLimits) return 'minimal';

    const totalResources = (resourceLimits.cpu || 0) + (resourceLimits.memory || 0) + (resourceLimits.apiCalls || 0);

    if (totalResources <= 100) return 'minimal';
    if (totalResources <= 300) return 'moderate';
    return 'high';
  }

  /**
     * Analyze repository activity patterns
     * @returns {Object} Activity analysis with patterns and confidence
     */
  getRepositoryActivityAnalysis () {
    const cacheKey = 'activity_analysis';
    const cached = this.getCachedData(cacheKey);
    if (cached) return cached;

    // Simulate activity analysis (would integrate with actual Git/GitHub data)
    const analysis = {
      patterns: this.detectActivityPatterns(),
      peakHours: this.detectPeakHours(),
      quietPeriods: this.detectQuietPeriods(),
      developerTimezones: this.detectDeveloperTimezones(),
      confidence: 0.85
    };

    this.setCachedData(cacheKey, analysis);
    return analysis;
  }

  /**
     * Detect activity patterns from repository data
     */
  detectActivityPatterns () {
    // This would analyze actual commit/PR/issue data
    // For now, return simulated patterns based on common development cycles
    return {
      weeklyPattern: {
        monday: 0.9, // High activity start of week
        tuesday: 1.0, // Peak activity
        wednesday: 0.95,
        thursday: 0.8,
        friday: 0.6, // Lower activity end of week
        saturday: 0.2, // Weekend low activity
        sunday: 0.1
      },
      dailyPattern: {
        morning: 0.7, // 6-12 UTC
        afternoon: 1.0, // 12-18 UTC (peak)
        evening: 0.8, // 18-24 UTC
        night: 0.2 // 0-6 UTC
      },
      seasonality: {
        businessHours: 0.9,
        afterHours: 0.3,
        holidays: 0.1
      }
    };
  }

  /**
     * Detect peak activity hours
     */
  detectPeakHours () {
    // Based on RepairGPT research and common development patterns
    return {
      weekdays: [14, 17, 20], // 2PM, 5PM, 8PM UTC
      weekends: [9, 13], // 9AM, 1PM UTC
      confidence: 0.85
    };
  }

  /**
     * Detect quiet periods for heavy processing
     */
  detectQuietPeriods () {
    return {
      weekdays: [1, 5, 9], // 1AM, 5AM, 9AM UTC
      weekends: [1, 5], // 1AM, 5AM UTC
      confidence: 0.90
    };
  }

  /**
     * Detect developer timezone distribution
     */
  detectDeveloperTimezones () {
    // This would analyze commit timestamps to detect developer locations
    return {
      primary: 'UTC+0',
      distribution: {
        'UTC-8': 0.2, // West Coast US
        'UTC-5': 0.3, // East Coast US
        'UTC+0': 0.3, // Europe
        'UTC+8': 0.2 // Asia
      },
      confidence: 0.75
    };
  }

  /**
     * Apply timezone optimization to schedule
     */
  applyTimezoneOptimization (schedule, targetTimezone) {
    if (schedule.type === 'smart' && schedule.cron.weekdays) {
      // Adjust smart automation times based on target timezone
      const offset = this.getTimezoneOffset(targetTimezone);

      schedule.cron.weekdays = schedule.cron.weekdays.map(cronExpr =>
        this.adjustCronForTimezone(cronExpr, offset)
      );
      schedule.cron.weekends = schedule.cron.weekends.map(cronExpr =>
        this.adjustCronForTimezone(cronExpr, offset)
      );

      schedule.timezoneOptimized = true;
      schedule.targetTimezone = targetTimezone;
    }

    return schedule;
  }

  /**
     * Apply activity pattern optimization
     */
  applyActivityOptimization (schedule, activityAnalysis) {
    if (schedule.type === 'rapid') {
      // Adjust rapid automation frequency based on activity patterns
      const currentHour = new Date().getUTCHours();
      const isBusinessHours = currentHour >= 8 && currentHour <= 18;

      if (isBusinessHours && activityAnalysis.patterns.dailyPattern.afternoon > 0.8) {
        // Increase frequency during high activity periods
        schedule.cron = '*/3 * * * *'; // Every 3 minutes instead of 5
        schedule.activityOptimized = true;
      }
    }

    if (schedule.type === 'smart') {
      // Use quiet periods for smart automation
      const quietHours = activityAnalysis.quietPeriods;
      schedule.preferredExecutionHours = quietHours;
    }

    return schedule;
  }

  /**
     * Apply resource optimization to prevent contention
     */
  applyResourceOptimization (schedule, resourceAnalysis) {
    if (resourceAnalysis.contention > 0.7) {
      // High contention - adjust schedule
      if (schedule.type === 'ultimate') {
        schedule.cron = '*/2 * * * *'; // Reduce from every minute to every 2 minutes
      } else if (schedule.type === 'rapid') {
        schedule.cron = '*/7 * * * *'; // Reduce from 5 to 7 minutes
      }

      schedule.resourceOptimized = true;
      schedule.originalCron = schedule.cron;
    }

    return schedule;
  }

  /**
     * Get current resource analysis
     */
  getResourceAnalysis () {
    const cacheKey = 'resource_analysis';
    const cached = this.getCachedData(cacheKey);
    if (cached) return cached;

    const analysis = {
      github: this.analyzeGitHubResources(),
      system: this.analyzeSystemResources(),
      contention: 0.3, // Simulated contention level
      status: 'normal'
    };

    // Determine overall status
    if (analysis.contention > 0.8) {
      analysis.status = 'high_contention';
    } else if (analysis.contention > 0.6) {
      analysis.status = 'moderate_contention';
    }

    this.setCachedData(cacheKey, analysis);
    return analysis;
  }

  /**
     * Analyze GitHub API and Actions resource usage
     */
  analyzeGitHubResources () {
    // This would integrate with GitHub API to get actual usage
    return {
      apiCallsUsed: 1200,
      apiCallsLimit: 5000,
      apiCallsRemaining: 3800,
      actionsMinutesUsed: 150,
      actionsMinutesLimit: 2000,
      concurrentActions: 2,
      rateLimitReset: new Date(Date.now() + 3600000), // 1 hour
      efficiency: 0.85
    };
  }

  /**
     * Analyze system resource usage
     */
  analyzeSystemResources () {
    // This would integrate with system monitoring
    return {
      cpu: { usage: 45, threshold: 80 },
      memory: { usage: 62, threshold: 85 },
      disk: { usage: 30, threshold: 90 },
      network: { latency: 50, bandwidth: 85 },
      status: 'healthy'
    };
  }

  /**
     * Check if execution should proceed based on current conditions
     * @param {string} tier - Automation tier
     * @param {Object} options - Check options
     * @returns {Object} Execution decision with reasoning
     */
  shouldExecute (tier, options = {}) {
    const schedule = this.getOptimalSchedule(tier, options);
    const currentTime = new Date();
    const resourceAnalysis = this.getResourceAnalysis();

    const checks = {
      timeWindow: this.isInOptimalTimeWindow(tier, currentTime),
      resources: this.areResourcesAvailable(tier, resourceAnalysis),
      cooldown: this.isCooldownExpired(tier),
      contention: this.isContentionAcceptable(tier, resourceAnalysis),
      override: options.forceExecution || false
    };

    const shouldExecute = checks.override || (
      checks.timeWindow &&
            checks.resources &&
            checks.cooldown &&
            checks.contention
    );

    return {
      shouldExecute,
      checks,
      reasoning: this.generateExecutionReasoning(checks),
      nextOptimalTime: shouldExecute ? null : this.getNextOptimalTime(tier),
      schedule
    };
  }

  /**
     * Check if current time is in optimal execution window
     */
  isInOptimalTimeWindow (tier, currentTime) {
    if (tier === 'ultimate') return true; // Ultimate runs anytime

    const hour = currentTime.getUTCHours();
    const day = currentTime.getUTCDay();
    const isWeekend = day === 0 || day === 6;

    if (tier === 'rapid') {
      // Avoid peak hours for rapid automation
      const peakHours = [14, 17, 20];
      return !peakHours.includes(hour) || isWeekend;
    }

    if (tier === 'smart') {
      // Smart automation has specific windows
      const optimalHours = isWeekend ? [1, 5, 9, 13] : [14, 17, 20];
      return optimalHours.includes(hour);
    }

    return true;
  }

  /**
     * Check if sufficient resources are available
     */
  areResourcesAvailable (tier, resourceAnalysis) {
    const requirements = {
      ultimate: { cpu: 20, memory: 30, api: 10 },
      rapid: { cpu: 40, memory: 50, api: 25 },
      smart: { cpu: 60, memory: 70, api: 50 }
    };

    const req = requirements[tier];
    const sys = resourceAnalysis.system;
    const github = resourceAnalysis.github;

    return (
      sys.cpu.usage + req.cpu < sys.cpu.threshold &&
            sys.memory.usage + req.memory < sys.memory.threshold &&
            github.apiCallsRemaining > req.api
    );
  }

  /**
     * Check if cooldown period has expired
     */
  isCooldownExpired (tier) {
    const lastExecution = this.getLastExecutionTime(tier);
    if (!lastExecution) return true;

    const cooldowns = {
      ultimate: 0, // No cooldown
      rapid: 5, // 5 minutes
      smart: 180 // 3 hours
    };

    const cooldownMs = cooldowns[tier] * 60 * 1000;
    return Date.now() - lastExecution > cooldownMs;
  }

  /**
     * Check if resource contention is acceptable
     */
  isContentionAcceptable (tier, resourceAnalysis) {
    const maxContention = {
      ultimate: 0.9, // Can run even with high contention
      rapid: 0.7, // Moderate contention acceptable
      smart: 0.5 // Low contention required
    };

    return resourceAnalysis.contention <= maxContention[tier];
  }

  /**
     * Generate human-readable reasoning for execution decision
     */
  generateExecutionReasoning (checks) {
    const reasons = [];

    if (checks.override) {
      reasons.push('Execution forced by override flag');
    } else {
      if (!checks.timeWindow) reasons.push('Outside optimal time window');
      if (!checks.resources) reasons.push('Insufficient resources available');
      if (!checks.cooldown) reasons.push('Cooldown period not expired');
      if (!checks.contention) reasons.push('Resource contention too high');
    }

    if (reasons.length === 0) {
      reasons.push('All conditions met for optimal execution');
    }

    return reasons.join(', ');
  }

  /**
     * Get next optimal execution time
     */
  getNextOptimalTime (tier) {
    const now = new Date();
    const schedule = this.getOptimalSchedule(tier);

    if (tier === 'smart' && schedule.cron.weekdays) {
      // Calculate next smart automation window
      return this.getNextSmartWindow(now, schedule);
    } else {
      // For ultimate and rapid, next time is soon
      const minutes = tier === 'ultimate' ? 1 : 5;
      return new Date(now.getTime() + minutes * 60 * 1000);
    }
  }

  /**
     * Calculate next smart automation window
     */
  getNextSmartWindow (currentTime, _schedule) {
    const currentHour = currentTime.getUTCHours();
    const currentDay = currentTime.getUTCDay();
    const isWeekend = currentDay === 0 || currentDay === 6;

    const availableHours = isWeekend ? [1, 5, 9, 13] : [14, 17, 20];

    // Find next available hour today
    const nextHourToday = availableHours.find(hour => hour > currentHour);

    if (nextHourToday) {
      const nextTime = new Date(currentTime);
      nextTime.setUTCHours(nextHourToday, 0, 0, 0);
      return nextTime;
    }

    // No more windows today, find first window tomorrow
    const nextDay = new Date(currentTime);
    nextDay.setUTCDate(nextDay.getUTCDate() + 1);
    const nextDayIsWeekend = nextDay.getUTCDay() === 0 || nextDay.getUTCDay() === 6;
    const nextDayHours = nextDayIsWeekend ? [1, 5, 9, 13] : [14, 17, 20];

    nextDay.setUTCHours(nextDayHours[0], 0, 0, 0);
    return nextDay;
  }

  /**
     * Get timezone offset from UTC using moment-timezone
     */
  getTimezoneOffset (timezone) {
    try {
      const now = moment.tz(timezone);
      return now.utcOffset() / 60; // Convert minutes to hours
    } catch (error) {
      console.warn(`Invalid timezone: ${timezone}, falling back to UTC`);
      return 0;
    }
  }

  /**
     * Adjust cron expression for timezone using moment-timezone
     */
  adjustCronForTimezone (cronExpr, offsetHours) {
    const parts = cronExpr.split(' ');
    const hour = parseInt(parts[1]);
    const minute = parseInt(parts[0]);

    // Create a moment object for today at the specified hour/minute in UTC
    const utcTime = moment.utc().hour(hour).minute(minute);

    // Apply timezone offset
    const adjustedTime = utcTime.clone().add(offsetHours, 'hours');

    parts[0] = adjustedTime.minute().toString();
    parts[1] = adjustedTime.hour().toString();

    return parts.join(' ');
  }

  /**
     * Get last execution time for tier (mock implementation)
     */
  getLastExecutionTime (tier) {
    // This would integrate with actual execution tracking
    const mockTimes = {
      ultimate: Date.now() - 30000, // 30 seconds ago
      rapid: Date.now() - 300000, // 5 minutes ago
      smart: Date.now() - 7200000 // 2 hours ago
    };
    return mockTimes[tier];
  }

  /**
     * Get next recommended schedule review time
     */
  getNextReviewTime () {
    // Review schedules weekly
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    nextWeek.setHours(0, 0, 0, 0);
    return nextWeek.toISOString();
  }

  /**
     * Cache management helpers
     */
  getCachedData (key) {
    const cached = this.activityCache.get(key);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }
    return null;
  }

  setCachedData (key, data) {
    this.activityCache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  /**
     * Get comprehensive schedule recommendations
     * @param {Object} options - Analysis options
     * @returns {Object} Complete schedule analysis and recommendations
     */
  getScheduleRecommendations (options = {}) {
    const tiers = ['ultimate', 'rapid', 'smart'];
    const recommendations = {};

    for (const tier of tiers) {
      const schedule = this.getOptimalSchedule(tier, options);
      const execution = this.shouldExecute(tier, options);

      recommendations[tier] = {
        schedule,
        execution,
        performance: this.analyzeSchedulePerformance(tier),
        optimization: this.getOptimizationSuggestions(tier, schedule)
      };
    }

    return {
      recommendations,
      globalOptimizations: this.getGlobalOptimizations(),
      summary: this.generateScheduleSummary(recommendations),
      generatedAt: new Date().toISOString()
    };
  }

  /**
     * Analyze schedule performance metrics
     */
  analyzeSchedulePerformance (tier) {
    // Mock performance data - would integrate with actual metrics
    return {
      averageExecutionTime: {
        ultimate: 35000, // 35 seconds
        rapid: 180000, // 3 minutes
        smart: 600000 // 10 minutes
      }[tier],
      successRate: {
        ultimate: 0.92,
        rapid: 0.88,
        smart: 0.95
      }[tier],
      resourceEfficiency: {
        ultimate: 0.85,
        rapid: 0.90,
        smart: 0.95
      }[tier],
      lastWeekExecutions: {
        ultimate: 10080, // Every minute
        rapid: 2016, // Every 5 minutes
        smart: 21 // 3 times per day
      }[tier]
    };
  }

  /**
     * Get optimization suggestions for a tier
     */
  getOptimizationSuggestions (tier, _schedule) {
    const suggestions = [];
    const performance = this.analyzeSchedulePerformance(tier);

    if (performance.successRate < 0.9) {
      suggestions.push(`Consider reducing ${tier} tier frequency to improve success rate`);
    }

    if (performance.resourceEfficiency < 0.85) {
      suggestions.push(`Optimize ${tier} tier resource usage for better efficiency`);
    }

    if (tier === 'ultimate' && performance.averageExecutionTime > 40000) {
      suggestions.push('Ultimate tier exceeding 40s target - review implementation complexity');
    }

    return suggestions;
  }

  /**
     * Get global optimization suggestions
     */
  getGlobalOptimizations () {
    return [
      'Consider implementing intelligent queueing to prevent tier conflicts',
      'Add predictive scaling based on repository activity patterns',
      'Implement cost optimization by preferring lower tiers during off-peak hours',
      'Add geographic distribution for better global coverage'
    ];
  }

  /**
     * Generate executive summary of schedule analysis
     */
  generateScheduleSummary (recommendations) {
    const activeSchedules = Object.keys(recommendations).length;
    const averageSuccessRate = Object.values(recommendations)
      .reduce((sum, rec) => sum + rec.performance.successRate, 0) / activeSchedules;

    return {
      activeSchedules,
      averageSuccessRate: Math.round(averageSuccessRate * 100) + '%',
      status: averageSuccessRate > 0.9 ? 'optimal' : 'needs-attention',
      criticalIssues: this.identifyCriticalIssues(recommendations),
      nextMaintenanceWindow: this.getNextMaintenanceWindow()
    };
  }

  /**
     * Identify critical scheduling issues
     */
  identifyCriticalIssues (recommendations) {
    const issues = [];

    for (const [tier, rec] of Object.entries(recommendations)) {
      if (rec.performance.successRate < 0.8) {
        issues.push(`${tier} tier has low success rate (${Math.round(rec.performance.successRate * 100)}%)`);
      }

      if (rec.execution.checks.resources === false) {
        issues.push(`${tier} tier resource constraints detected`);
      }
    }

    return issues;
  }

  /**
     * Get next maintenance window
     */
  getNextMaintenanceWindow () {
    // Schedule maintenance during lowest activity (weekends, early morning UTC)
    const now = new Date();
    const nextSunday = new Date(now);
    nextSunday.setDate(now.getDate() + (7 - now.getDay()));
    nextSunday.setUTCHours(2, 0, 0, 0); // 2 AM UTC Sunday

    return nextSunday.toISOString();
  }
}

module.exports = IntelligentScheduleManager;
